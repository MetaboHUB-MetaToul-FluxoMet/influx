#!/usr/bin/env python
# Transform .ftbl file to a symbolic matrix A and its right part b
# in A*x=b. Resulting file can be used in source() operator
# in R langage (but repeteive calls could take advantage of parse()-eval()
# couple). After its execution it will define
# Al, Ac, Au spA, and b are lists indexed by cumomer weight. Each list element
# will correspond to a system of given weght. l,c, u idicate lower, central
# and upper diagonals in tridiagonal matrix. spA is a sparse part of the
# the complete matrix A without three main diagonals stored in Al, Ac, Au.
# All lists can to be initialized in R calling environement. If not,
# we initialize them in an if block so that
# in repetitive calls we dont have to manipulate large chunks of memory.
# Flux vector fl can already be known in R environement and indexed by
# the same metabolite names as in .ftbl file.
# Cumomers cm is a list of vectors cm[weight][cumomer] where cumomer is
# a string like metab:123, here metab is metabolite name and 123 is
# cumomer decimal index

# usage: ./ftbl2symAb.py < organism.ftbl > organism_sAb.R

# 2008-04-17 sokol

import sys;
import time;

sys.path.append('/home/sokol/dev/python');
from tools_ssg import *;
import C13_ftbl;

# parse ftbl from stdin
ftbl=C13_ftbl.ftbl_parse(sys.stdin);

# analyse network
netan=C13_ftbl.ftbl_netan(ftbl);

# cumomer balance equations
f=sys.stdout;
f.write("# This is automatically generated R code. Don't edit.\n");
f.write("# Generated by "+sys.argv[0]+" at "+time.ctime()+".\n");
f.write("""
# Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.

# init some constants
nw=%d; # maximal cumomer weight

# Initialize the lists if necessary (Ac is used as indicator for all other lists)
if (! "Ac" %%in%% ls()) {
   require(Matrix);
   Al=Ac=Au=spA=b=cumos=ncumo=list();
   nx=0;  # length of cumomer vector x (each weight will add a chunk)
   x=vector("numeric",0);
}

# assign variables weight by weight;
""" % netan['Cmax']);
#pdb.set_trace();
for w in xrange(1,netan['Cmax']+1):
##    cumos=netan['cumo_sys']['A'][w-1].keys(); # weight 1 equations have all metabolites
    # order cumos along pathways
    # starts are cumomers having input cumomers in rhs
    starts=[cumo for cumo,fluxes in netan['cumo_sys']['b'][w-1].iteritems() \
        if any((cur_cumo.split(':')[0] in netan['input']) \
        for cur_cumo in valval(fluxes.values()))];
    # complete starts by all others cumomers
    starts+=[c for c in netan['cumo_sys']['A'][w-1] if not c in starts];
    cumo_paths=C13_ftbl.cumo_path(starts, netan['cumo_sys']['A'][w-1], set());
    # order
    cumos=[cumo for cumo in valval(cumo_paths)];
    ncumo=len(cumos);
    #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
    if ncumo != len(netan['cumo_sys']['A'][w-1]):
        raise "wrongCumomerNumber";
    #metab_paths=netan['metab_paths']; # ordered by pathways
    f.write("""
iw=%d;
if (length(Ac) < iw) {
   # initialiaze cumomer names
   cumos[[iw]]=c("%s");
   ncumo[[iw]]=length(cumos);
   # init cumomer dependent vectors
   Al[[iw]]=Ac[[iw]]=Au[[iw]]=b[[iw]]=vector("numeric", ncumo[[iw]]);
   x=c(x,vector("numeric", ncumo[[iw]]);
   names(Al[[iw]])=names(Ac[[iw]])=names(Au[[iw]])=names(b[[iw]])=cumos[[iw]];
   names(x[(nx+1):(nx+ncumo[[iw]])]=cumos[[iw]];
   # ... and sparse part of the matrix
   spA[[iw]]=Matrix(0., ncumo[[iw]], ncumo[[iw]]);
   dimnames(spA[[iw]])=list(cumos[[iw]],cumos[[iw]]);
}""" % (w, '","'.join(cumos)));
    
    f.write("""
# central diagonal
Ac[[iw]]=c(%s);
# lower diagonal (first element is a garbage)
Al[[iw]]=c(%s);
# upper diagonal (last element is a garbage)
Au[[iw]]=c(%s);""" % (
    ','.join(fl_join(netan['cumo_sys']['A'][w-1][cumo][cumo]) for cumo in cumos),
    ','.join(netan['cumo_sys']['A'][w-1][cumos[i]].get(cumos[i-1],"0.") for i in xrange(ncumo)),
    ','.join(netan['cumo_sys']['A'][w-1][cumos[i]].get(cumos[(i+1)%ncumo],"0.") for i in xrange(ncumo)),
    ));
    # sparse part
    for icol in xrange(ncumo):
        for irow in xrange(ncumo):
            if (irow > icol+1 or irow < icol-1):
                continue;
            term=netan['cumo_sys']['A'][w-1][cumos[irow]].get(cumos[icol],'');
            if (not term):
                continue;
            f.write("spA[[iw]][%d,%d]=%s;\n" % (irow,icol,term));
    
    f.write("""
# right hand side term b
b=c(%s);

# solve the system A[[iw]]*x[<iw part>]=b[[iw]];
# x has to be global for all iw if we want to calculate b in simple way
""" % (
    ','.join(
    '+'.join(
    (flux+'*('+'*'.join('x["'+cumo_c+'"]'
    for cumo_c in cumo_contibs)+')') if len(cumo_contibs) else '0.'
    for flux,cumo_contibs in \
    netan['cumo_sys']['b'][w-1].get(cumo,{'':[]}).iteritems()
    )
    for cumo in cumos
    )
    ));

#f.close(); # no need to close stdout
