#!/usr/bin/env python

"""Module for translation of .ftbl file to R code"""

# 2012-02-21 sokol@insa-toulouse.fr : cumomer matrices and rhs from sparse matrices
#                                     (without fortran code)
# 2009-09-14 sokol@insa-toulouse.fr : flux.[net|xch] -> [dfc].[nx].flux
#                                     flux.[fwd|rev] -> [fwd|rev].flux
# 2008-12-08 sokol@insa-toulouse.fr : added netan2Rinit()
# 2008-11-25 sokol@insa-toulouse.fr : adapted for reduced cumomer list
# 2008-09-19 sokol@insa-toulouse.fr : initial release
# Copyright 2011, INRA

import time;
import copy;
import os;
import sys;
from operator import itemgetter;
from itertools import groupby;

global DEBUG;
me=os.path.realpath(sys.argv[0]);
dirx=os.path.dirname(me);
sys.path.append(dirx);

from tools_ssg import *;
import C13_ftbl;

def fwrap(text, comment=False):
    """Wraps the text in fortran style, i.e. last char at colomn 72 and
    the following lines are prepended with "     &" (five spaces and ampresand)
    If parameter comment is True then the wrapped text is prepended
    with "C ".
    """
    lent=len(text);
    if comment:
        return "\nC ".join(text[i:min(i+72,lent)] for i in xrange(0, lent, 72));
    else:
        return text[0:72]+("\n     &" if lent > 72 else "")+"\n     &".join(text[i:min(i+66,lent)] for i in xrange(72, lent, 66));

def netan2Abcumo_f(Al, bl, vcumol, minput, f, fwrv2i, incu2i_b1, fortfun="fwrv2Abcumo"):
    """
    Transform cumomer linear sytems collection (from ftbl file)
    to a Fortran subroutine code calculating matrix A and vector b
    in A*x=b for a given weight iw (input Fortran parameter)
    Flux vector fl of all fwd. and rev. fluxes is known from
    Fortran parameter list"""

    #2008-08-26 sokol
    
    f.write("""
C************************************************************************
C Define subroutine for cumomer matrix A for a given weight iw
C NB: This is an automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.
C
C************************************************************************


      SUBROUTINE %(fortfun)s(fl, nf, x, iw, n, A, b, calcA, calcb)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C Calculate dense matrix for system of linear equations A*x=b
C for cumomer vector x of a given weight iw.
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): composite array of 1, input cumomers and lighter cumomers
C iw (int): weight for which the matrix should be calculated
C n (int): A dimension (n x n)
C Output:
C A (double): array(n,n) representing the system matrix.
C b (double): array(n) representing the system rhs.
      INTEGER            nf
      INTEGER            nx
      INTEGER            iw
      INTEGER            n
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(*)
      DOUBLE PRECISION   A(n,n)
      DOUBLE PRECISION   b(n)
      LOGICAL            calcA
      LOGICAL            calcb
      
C      write(0,*) "%(fortfun)s: start", nf, iw, n
%(fluxe_names)s
%(incu_names)s
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    "fortfun": fortfun,
    "fluxe_names": fwrap("C fluxes: "+join(", ",
     (str(i)+"="+f for (f,i) in sorted(fwrv2i.iteritems()))),
     comment=True),
    "incu_names": fwrap("C incu=c(1,input,x): "+join(", ",
     (str(i)+"="+c for (c,i) in sorted(incu2i_b1.iteritems()))),
     comment=True)
    });
    for (iwl,A) in enumerate(Al):
        w=iwl+1;
        cumos=vcumol[iwl];
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        matrix definition
C        cumos: %(cumos)s
         if (calcA) then
"""%    {
        "iw": w,
        "cumos": join(", ", [(i+1,c) for (i,c) in enumerate(cumos)]),
        });
        # run through the matrix
        for icol in xrange(ncumo):
            f.write("C           (%d,%d) cumo=%s\n" % (icol+1, icol+1, cumos[icol]));
            for irow in xrange(ncumo):
                sign="-" if (irow != icol) else "";
                fli=A[cumos[irow]].get(cumos[icol],[]);
                #if set(fli)-set(fwrv2i.keys()):
                #    raise Exception("A 1ir,1ic=%d,%d: fluxes %s are not in fwrv2i."%
                #        irow+1, icol+1, set(fli)-set(fwrv2i.keys()));
                term=join('+', trd(fli, fwrv2i, 'fl(', ')', None));
                if (not term):
                    continue;
                code="            A(%(ir)d,%(ic)d)=%(sign)s(%(term)s)\n" % {
                "ir": irow+1,
                "ic": icol+1,
                "sign": sign,
                "term": term,
                };
                f.write(fwrap(code));
        # run through the rhs
        f.write("""
         endif
C        right hand side definition
         if (calcb) then
%(b)s
         endif
      endif
""" %   {
        "b": (
        join("\n", (
        fwrap("            b("+str(i+1)+")="+join("+",
        ("fl("+str(fwrv2i[flux])+")*(" +
        joint("+", [
        join("*", trd(lst, incu2i_b1, "x(", ")", None))
        for (imetab,lst) in dlst.iteritems()
        ])+")"
        for (flux,dlst) in bl[iwl].get(cumo,{}).iteritems()
        ), a="0."))
        for (i,cumo) in enumerate(cumos)
        )
        )
        )
        });
    f.write("""
      RETURN
      END SUBROUTINE %(fortfun)s
"""%{"fortfun": fortfun});

def netan2Abcumo_sp(varname, Al, bl, vcumol, minput, f, fwrv2i, incu2i_b1):
    """
    Transform cumomer linear sytems collection (from ftbl file)
    to a R code calculating sparse matrix A and vector b
    in A*x=b for a given weight iw (index in resulting list)
    Flux vector fl of all fwd. and rev. fluxes is known from
    R environement.
    
    Resulting code is a list spAb indexed by cumomer weight
    (cf. generated R comments for details on spAb)
    cumomer vector incu=c(1, xi, xl), xi - input, xl - lighter cumomers.
    
    incu2i_b1 gives i in incu from cumomer name. i=1 corresponds to the constant 1.
    """
    #2010-10-15 sokol
    
    nb_cumu=cumsum(len(l) for l in vcumol);
    f.write(
    """
# sparse matrix static parts
# $varname fields:
#  tA - unsigned sparse transpose of cumomer A matrix (off-diagonal part)
#   @i, @p and @x slots are those from Matrix::dgCMatrix class
#  f2ax indexes of fluxes to calculate tA@x slot (cf. fortran
#   f2ax() subroutine in cumo.f)
#  bfpr - unsigned sparse rhs of Ax=b.
#   [(irow, iflux, incu_index1, incu_index2),...]
#   to calculate terms like flux*x1*x2. When there is only one
#   term x, x2 is set to 1
#  ta_fx - unsigned sparse matrix t(dA_df*x)
#   @i run through the fluxes contibuting to a row of dA_df*x
#  x2ta_fx - 1-based indexes of x0=c(0,x) for dA_df*x which is
#   comosed of differences (x_diag - x_off-diag) and (x_diag)
#   when flux is in b term. In this case index of x_off-diag is
#   set to 1 (i.e. 0-value in x0).
#   [irow, ixoff] irow is actually ixdiag
#  tb_f - unsigned sparse matrix t(db_df) with indexes ix1, ix2 for product as in bfpr
#   @i is running along fluxes
#  x2tb_f - 2 row matrix with indexes ix1, ix2 for product as in bfpr
#  tb_x - unsigned sparse transpose of db_dx over x in lighter weights
#   @i runs over lighter cumomers

nb_fwrv=%(n)d;
%(var)s=list();
"""%{
    "var": varname,
    "n": len(fwrv2i),
    #"lcu": join(", ", (len(l) for l in vcumol))
});
    # base of cumomers in composed vector incu=c(1, input, xcumo)
    # +1 for c(1,...)
    ba_x=len(incu2i_b1) - sum(len(l) for l in vcumol)+1;
    ba_xw=ba_x; # base for current weigth cumomer in incu
    ncucumo=0;
    for (iwl,A) in enumerate(Al):
        w=iwl+1;
        b=bl[iwl];
        cumos=vcumol[iwl];
        ncumo=len(cumos);
        c2i=dict((c,i) for (i,c) in enumerate(cumos));
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        l_ia=[]; # list of non zero off-diagonal elements in A / row
        l_ib=[]; # list of non zero elements in b / row
        for irow in xrange(ncumo):
            cr=cumos[irow];
            row=A[cr];
            # atuple is list of (icumo, list(fluxes))
            atuple=[(c2i[c], [fwrv2i[fl] for fl in l])
                for (c,l) in row.iteritems() if c!=cr];
            # btuple is list of (iflux, icumo1, icumo2)
            if cr in b:
                btuple=[(fwrv2i[fl], incu2i_b1[l[0]], (incu2i_b1[l[1]] if len(l)==2 else 1))
                    for (fl, d) in b[cr].iteritems()
                    for (i,l) in d.iteritems()];
            else:
                btuple=[];
            # one list per row
            l_ia.append(atuple);
            l_ib.append(btuple);
        f.write(
"""
w=%(w)d;
nb_c=%(nbc)d;
%(var)s[[w]]=list();
%(var)s[[w]]$tA=as(Matrix(0, nrow=nb_c, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$tA@i=as.integer(c(%(ia)s));
%(var)s[[w]]$tA@p=as.integer(c(%(pa)s));
%(var)s[[w]]$tA@x=rep(0., length(%(var)s[[w]]$tA@i)); # place holder

%(var)s[[w]]$f2ta=matrix(as.integer(c(%(f2ta)s)), nrow=2);
%(var)s[[w]]$bfpr=matrix(as.integer(c(%(bfpr)s)), nrow=4);

%(var)s[[w]]$ta_fx=as(Matrix(0, nrow=nb_fwrv, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$ta_fx@i=as.integer(c(%(ia_fx)s));
%(var)s[[w]]$ta_fx@p=as.integer(c(%(pa_fx)s));
%(var)s[[w]]$ta_fx@x=rep(0., length(%(var)s[[w]]$ta_fx@i)); # place holder

%(var)s[[w]]$x2ta_fx=matrix(as.integer(c(%(x2ta_fx)s)), nrow=3);

%(var)s[[w]]$tb_f=as(Matrix(0, nrow=nb_fwrv, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$tb_f@i=as.integer(c(%(ibf)s));
%(var)s[[w]]$tb_f@p=as.integer(c(%(pbf)s));
%(var)s[[w]]$tb_f@x=rep(0., length(%(var)s[[w]]$tb_f@i)); # place holder

%(var)s[[w]]$x2tb_f=matrix(as.integer(c(%(x2tb_f)s)), nrow=2);

%(var)s[[w]]$tb_x=as(Matrix(0, nrow=%(ncucumo)d, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$tb_x@i=as.integer(c(%(ib_x)s));
%(var)s[[w]]$tb_x@p=as.integer(c(%(pb_x)s));
%(var)s[[w]]$tb_x@x=rep(0., length(%(var)s[[w]]$tb_x@i)); # place holder

%(var)s[[w]]$fx2tb_x=matrix(as.integer(c(%(fx2tb_x)s)), nrow=3);
"""%{
   "var": varname,
   "w": w,
   "nbc": ncumo,
   "ncucumo": ncucumo,
   "ia": join(", ", [ix
       for lt in l_ia
       for (ix, lf) in sorted(lt)
       ]),
   "pa": join(", ", cumsum(len(lt) for lt in l_ia)),
   "f2ta": join(", ", valval((len(lf), ifl)
       for lt in l_ia
       for (ix, lf) in sorted(lt)
       for ifl in lf)),
   "bfpr": join(", ", valval((ir+1, ifl, i1, i2)
       for (ir, lt) in enumerate(l_ib)
       for (ifl, i1, i2) in lt)),
   "ia_fx": join(", ", (ifl-1
       for (ir, lt) in enumerate(l_ia)
       for ifl in sorted(set([f for (ix, lf) in lt for f in lf]+
       [f for (f,i1,i2) in l_ib[ir]]))
   )), # a flux is not unique in a given row of A, because of split reactions in two identical metabolites
   "pa_fx": join(", ", cumsum(
       len(set([f for ix,lf in lt for f in lf]+
       [f for f,i1,i2 in l_ib[ir]]))
       for (ir, lt) in enumerate(l_ia)
   )),
   "x2ta_fx": join(", ", valval((len(lg), ix, ir+ba_xw+2) # +2=+1 for c(0,incu), +1 for 1-based
       for (ir, lt) in enumerate(l_ia)
       for lg in [list(g) for k, g in
       groupby(sorted([(ifl, ix+ba_xw+2) for ix,lf in lt for ifl in lf]+
       [(ifl, 1) for ifl,i1,i2 in l_ib[ir]]), key=itemgetter(0))]
       for (ifl, ix) in lg
   )),
   "ibf": join(", ", (ifl-1
       for lt in l_ib
       for ifl in sorted(ifl for (ifl, i1, i2) in lt)
   )),
   "pbf": join(", ", cumsum(len(lt) for lt in l_ib)),
   "x2tb_f": join(", ", valval((ix1, ix2)
       for lt in l_ib
       for (ifl, ix1, ix2) in sorted(lt)
   )),
   "ib_x": join(", ", (icu-ba_x-1
       for lt in l_ib
       for icu in sorted(set(icu
       for (ifl, i1, i2) in lt
       for icu in (i1, i2) if icu > ba_x))
   )),
   "pb_x": join(", ", cumsum(len(set(icu
       for (ifl, i1, i2) in lt
       for icu in (i1, i2) if icu > ba_x))
       for lt in l_ib
   )),
   "fx2tb_x": join(", ", valval((len(lg), ifl, icof)
       for lt in l_ib
       for lg in (list(g)
       for k,g in groupby(sorted((icu, ifl, icof)
       for (ifl, i1, i2) in lt
       for (icu, icof) in ((i1,i2), (i2, i1))
       if icu > ba_x), key=itemgetter(0)))
       for (icu, ifl, icof) in lg
   )),
});
        ba_xw+=ncumo;
        ncucumo+=ncumo;

def netan2Abcumo_spr(varname, Al, bl, vcumol, minput, f, fwrv2i, incu2i_b1):
    """
    Transform cumomer linear sytems collection (from ftbl file)
    to a R code calculating sparse matrix A and vector b
    in A*x+b=0 for a given weight iw (index in resulting list)
    Flux vector fl of all fwd. and rev. fluxes is known from
    R environement.
    
    Resulting code is a list sprAb indexed by cumomer weight
    (cf. generated R comments for details on sprAb)
    cumomer vector incu=c(1, xi, xl), xi - input, xl - lighter cumomers.
    
    incu2i_b1 gives i in incu from cumomer name. i=1 corresponds to the constant 1.
    Difference wrt netan2Abcumo_sp is that pure R code is used
    (@i, @p and @x slots are those from Matrix::dgCMatrix class).
    No need for Fortran compiler.
    """
    #2012-02-08 sokol
    
    nb_cumu=cumsum(len(l) for l in vcumol);
    f.write(
    """
# sparse matrix static parts
# $varname fields:
#  ind_fa - flux index in a_pre@x=fwrv[ind_fa]
#  a_pre - sparse matrix whose colsum gives the at@x vector
#  ind_fb - flux index in b_pre@x=fwrv[ind_fb1]*x[ind_x1]*x[ind_x2]
#  ind_x1 - cumomer index in b_pre@x=fwrv[ind_fb]*x[ind_x1]*x[ind_x2]
#  ind_x2 - cumomer index in b_pre@x=fwrv[ind_fb]*x[ind_x1]*x[ind_x2]
#  b_pre - sparse matrix whose colsum gives b@x

#  tA - unsigned sparse transpose of cumomer A matrix (off-diagonal part)
#  b - unsigned sparse vector of right hand side
#  
#  f2ax indexes of fluxes to calculate tA@x slot (cf. fortran
#   f2ax() subroutine in cumo.f)
#  bfpr - unsigned sparse rhs of Ax=b.
#   [(irow, iflux, incu_index1, incu_index2),...]
#   to calculate terms like flux*x1*x2. When there is only one
#   term x, x2 is set to 1
#  ta_fx - unsigned sparse matrix t(dA_df*x)
#   @i run through the fluxes contibuting to a row of dA_df*x
#  x2ta_fx - 1-based indexes of x0=c(0,x) for dA_df*x which is
#   comosed of differences (x_diag - x_off-diag) and (x_diag)
#   when flux is in b term. In this case index of x_off-diag is
#   set to 1 (i.e. 0-value in x0).
#   [irow, ixoff] irow is actually ixdiag
#  tb_f - unsigned sparse matrix t(db_df) with indexes ix1, ix2 for product as in bfpr
#   @i is running along fluxes
#  x2tb_f - 2 row matrix with indexes ix1, ix2 for product as in bfpr
#  tb_x - unsigned sparse transpose of db_dx over x in lighter weights
#   @i runs over lighter cumomers

nb_fwrv=%(n)d;
%(var)s=list();
"""%{
    "var": varname,
    "n": len(fwrv2i),
    #"lcu": join(", ", (len(l) for l in vcumol))
});
    # base of cumomers in composed vector incu=c(1, input, xcumo)
    # +1 for c(1,...)
    ba_x=len(incu2i_b1) - sum(len(l) for l in vcumol)+1;
    ba_xw=ba_x; # base for current weigth cumomer in incu
    ncucumo=0;
    for (iwl,A) in enumerate(Al):
        w=iwl+1;
        b=bl[iwl];
        cumos=vcumol[iwl];
        ncumo=len(cumos);
        c2i=dict((c,i) for (i,c) in enumerate(cumos));
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        l_ia=[]; # list of non zero off-diagonal elements in A / row
        l_ib=[]; # list of non zero elements in b / row
        nb_maxfa=0; # hwo many fluxes in an off-diagonal term in a
        nb_maxfb=0; # hwo many fluxes in a term in b
        for irow in xrange(ncumo):
            cr=cumos[irow];
            row=A[cr];
            # atuple is list of (icumo, list(fluxes))
            atuple=[(c2i[c], [fwrv2i[fl] for fl in row[c]])
                for c in cumos if c in row and c!=cr];
            if atuple:
                nb_maxfa=max(nb_maxfa, max(len(lf) for (ic, lf) in atuple));
            elif cr not in b:
                raise Exception("Empty row in cumomer matrix, weight=%d (base 1), cumo=%s"%(w, cr))
            # btuple is list of (iflux, icumo1, icumo2)
            if cr in b:
                btuple=[(fwrv2i[fl], incu2i_b1[l[0]], (incu2i_b1[l[1]] if len(l)==2 else 1))
                    for (fl, d) in b[cr].iteritems()
                    for (i,l) in d.iteritems()];
                nb_maxfb=max(nb_maxfb, len(btuple));
            else:
                btuple=[];
            # one list per row
            l_ia.append(atuple);
            l_ib.append(btuple);
        f.write(
"""
w=%(w)d;
nb_c=%(nbc)d;
%(var)s[[w]]=list();
%(var)s[[w]]$tA=as(Matrix(0, nrow=nb_c, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$tA@i=as.integer(c(%(ia)s));
%(var)s[[w]]$tA@p=as.integer(c(%(pa)s));
#%(var)s[[w]]$tA@x=rep(0., length(%(var)s[[w]]$tA@i)); # place holder

nb_ax=length(%(var)s[[w]]$tA@i)
%(var)s[[w]]$a_pre=as(Matrix(0, nrow=%(nb_maxfa)d, ncol=nb_ax, sparse=T), "dgCMatrix");
%(var)s[[w]]$a_pre@i=as.integer(c(%(ia_pre)s));
%(var)s[[w]]$a_pre@p=as.integer(c(%(pa_pre)s));
#%(var)s[[w]]$a_pre@x=as.double(%(var)s[[w]]$a_pre@i); # place holder
%(var)s[[w]]$ind_fa=c(%(ind_fa)s);

%(var)s[[w]]$b=as(Matrix(0, nrow=nb_c, ncol=1, sparse=T), "dgCMatrix");
%(var)s[[w]]$b@i=as.integer(c(%(ib)s));
%(var)s[[w]]$b@p=as.integer(c(%(pb)s));
# %(var)s[[w]]$b@x is calculated at running time
%(var)s[[w]]$ind_fb=c(%(ind_fb)s);


nb_bx=length(%(var)s[[w]]$b@i)
%(var)s[[w]]$b_pre=as(Matrix(0, nrow=%(nb_maxfb)d, ncol=nb_bx, sparse=T), "dgCMatrix");
%(var)s[[w]]$b_pre@i=as.integer(c(%(ib_pre)s));
%(var)s[[w]]$b_pre@p=as.integer(c(%(pb_pre)s));
%(var)s[[w]]$ind_fb=c(%(ind_fb)s);
%(var)s[[w]]$ind_x1=c(%(ind_x1)s);
%(var)s[[w]]$ind_x2=c(%(ind_x2)s);

%(var)s[[w]]$ta_fx=as(Matrix(0, nrow=nb_fwrv, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$ta_fx@i=as.integer(c(%(ia_fx)s));
%(var)s[[w]]$ta_fx@p=as.integer(c(%(pa_fx)s));
#%(var)s[[w]]$ta_fx@x=rep(0., length(%(var)s[[w]]$ta_fx@i)); # place holder

%(var)s[[w]]$x2ta_fx=matrix(as.integer(c(%(x2ta_fx)s)), ncol=3, byrow=T);

%(var)s[[w]]$tb_f=as(Matrix(0, nrow=nb_fwrv, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$tb_f@i=as.integer(c(%(ibf)s));
%(var)s[[w]]$tb_f@p=as.integer(c(%(pbf)s));
#%(var)s[[w]]$tb_f@x=rep(0., length(%(var)s[[w]]$tb_f@i)); # place holder

%(var)s[[w]]$x2tb_f=matrix(as.integer(c(%(x2tb_f)s)), ncol=2, byrow=T);

%(var)s[[w]]$tb_x=as(Matrix(0, nrow=%(ncucumo)d, ncol=nb_c, sparse=T), "dgCMatrix");
%(var)s[[w]]$tb_x@i=as.integer(c(%(ib_x)s));
%(var)s[[w]]$tb_x@p=as.integer(c(%(pb_x)s));
%(var)s[[w]]$tb_x@x=rep(0., length(%(var)s[[w]]$tb_x@i)); # place holder

%(var)s[[w]]$fx2tb_x=matrix(as.integer(c(%(fx2tb_x)s)), ncol=3, byrow=T);
"""%{
   "var": varname,
   "w": w,
   "nbc": ncumo,
   "ncucumo": ncucumo,
   "ia": join(", ", [ix
       for lt in l_ia
       for (ix, lf) in sorted(lt)
       ]),
   "pa": join(", ", cumsum(len(lt) for lt in l_ia)),
   "f2ta": join(", ", valval((len(lf), ifl)
       for lt in l_ia
       for (ix, lf) in sorted(lt)
       for ifl in lf)),
   "bfpr": join(", ", valval((ir+1, ifl, i1, i2)
       for (ir, lt) in enumerate(l_ib)
       for (ifl, i1, i2) in lt)),
   "ia_fx": join(", ", (ifl-1
       for (ir, lt) in enumerate(l_ia)
       for ifl in sorted(set([f for (ix, lf) in lt for f in lf]+
       [f for (f,i1,i2) in l_ib[ir]]))
   )), # a flux is not unique in a given row of A, because of split reactions in two identical metabolites
   "pa_fx": join(", ", cumsum(
       len(set([f for ix,lf in lt for f in lf]+
       [f for f,i1,i2 in l_ib[ir]]))
       for (ir, lt) in enumerate(l_ia)
   )),
   "x2ta_fx": join(", ", valval((ilg, ix, ir+ba_xw+2) # +2 comes from +1 for c(0,incu), +1 for 1-based
       for (ir, lt) in enumerate(l_ia)
       for lg in [list(g) for k, g in
       groupby(sorted([(ifl, ix+ba_xw+2) for ix,lf in lt for ifl in lf]+
       [(ifl, 1) for ifl,i1,i2 in l_ib[ir]]), key=itemgetter(0))]
       for (ilg, (ifl, ix)) in enumerate(lg)
   )),
   "ibf": join(", ", (ifl-1
       for lt in l_ib
       for ifl in sorted(ifl for (ifl, i1, i2) in lt)
   )),
   "pbf": join(", ", cumsum(len(lt) for lt in l_ib)),
   "x2tb_f": join(", ", valval((ix1, ix2)
       for lt in l_ib
       for (ifl, ix1, ix2) in sorted(lt)
   )),
   "ib_x": join(", ", (icu-ba_x-1
       for lt in l_ib
       for icu in sorted(set(icu
       for (ifl, i1, i2) in lt
       for icu in (i1, i2) if icu > ba_x))
   )),
   "pb_x": join(", ", cumsum(len(set(icu
       for (ifl, i1, i2) in lt
       for icu in (i1, i2) if icu > ba_x))
       for lt in l_ib
   )),
   "fx2tb_x": join(", ", valval((ilg, ifl, icof)
       for lt in l_ib
       for lg in (list(g)
       for k,g in groupby(sorted((icu, ifl, icof)
       for (ifl, i1, i2) in lt
       for (icu, icof) in ((i1,i2), (i2, i1))
       if icu > ba_x), key=itemgetter(0)))
       for (ilg, (icu, ifl, icof)) in enumerate(lg)
   )),
   "ia_pre": join(", ", valval(range(len(lf))
       for row in l_ia
       for (ic, lf) in row
   )),
   "pa_pre": join(", ", cumsum(len(lf)
       for row in l_ia
       for (ic, lf) in row
   )),
   "ind_fa": join(", ", valval(lf
       for row in l_ia
       for (ic, lf) in row
   )),
   "nb_maxfa": nb_maxfa,
   "nb_maxfb": nb_maxfb,
   "ib_pre": join(", ", valval(range(len(row))
       for row in l_ib if len(row)
   )),
   "pb_pre": join(", ", cumsum(len(row)
       for row in l_ib if row
   )),
   "ind_fb": join(", ", (ifl
       for row in l_ib
       for (ifl, ic1, ic2) in row
   )),
   "ind_x1": join(", ", (ic1
       for row in l_ib
       for (ifl, ic1, ic2) in row
   )),
   "ind_x2": join(", ", (ic2
       for row in l_ib
       for (ifl, ic1, ic2) in row
   )),
   "ib": join(", ", [i
       for (i, row) in enumerate(l_ib) if row
       ]),
   "pb": join(", ", [0, len([i for i in l_ib if i])]),
});
        ba_xw+=ncumo;
        ncucumo+=ncumo;

def netan2Rinit(netan, org, f, fullsys):
    """netan2Rinit(netan, org, f, fullsys)
    Write R code for initialization of all variables before
    cumomer system resolution by khi2 minimization.
    netan is a collection of parsed ftbl information
    f is R code output pointer
    ff is fortran code output pointer
    fullsys=True means write also a code for the full cumomer system
    Return a dictionnary with some python variables:
        "measures": measures,
        "o_mcumos": o_mcumos,
        "cumo2i": cumo2i,
        ...
    """
    global DEBUG;
    # Important python variables:
    # Collections:
    #    netan - (dict) ftbl structured content;
    #    tfallnx - (3-tuple[reac,["d"|"f"|"c"], ["n"|"x"]] list)- total flux
    #    collection;
    #    measures - (dict) exp data;
    #    rAb - (list) reduced linear systems A*x_cumo=b by weight;
    #    scale - unique scale names;
    #    nrow - counts scale names;
    #    o_sc - ordered scale names;
    #    o_meas - ordered measure types;
    # org - (str) prefix of .ftbl  file like "PPP"
    # File names (str):
    #    n_ftbl (descriptor f_ftbl);
    #    n_opt (R code) (f);
    #    n_fort (fortran code) (ff);
    # Counts: nb_fln, nb_flx, nb_fl (dependent fluxes: net, xch, total),
    #         nb_ffn, nb_ffx (free fluxes)
    # Index translators:
    #    fwrv2i - flux names to index in fwrv 1-based;
    #    cumo2i - cumomer names to index in R:x;
    #    ir2isc - mapping measure rows indexes on scale index isc[meas]=ir2isc[meas][ir]
    # Vector names:
    #    cumos (list) - names of R:x;
    #    o_mcumos - cumomers involved in measures;

    # Important R variables:
    # Scalars:
    #    nb_w, nb_cumos, nb_fln, nb_flx, nb_fl (dependent or unknown fluxes),
    #    nb_ffn, nb_ffx, nb_ff (free fluxes),
    #    nb_fcn, nb_fcx, nb_fc (constrained fluxes),
    #    nb_ineq, nb_param, nb_fmn
    # Name vectors:
    #    nm_cumo, nm_fwrv, nm_fallnx, nm_fln, nm_flx, nm_fl, nm_par,
    #    nm_ffn, nm_ffx,
    #    nm_fcn, nm_fcx,
    #    nm_mcumo, nm_fmn
    # Numeric vectors:
    #    fwrv - all fluxes (fwd+rev);
    #    x - all cumomers (weight1+weight2+...);
    #    param - free flux net, free flux xch, scale label, scale mass, scale peak
    #    fcn, fcx, fc,
    #    bp - helps to construct the rhs of flux system
    #    fallnx - complete flux vector (dep, free, constr:net+xch)
    #    bc - helps to construct fallnx
    #    li - inequality vector (mi%*%fallnx>=li)
    #    ir2isc - measur row to scale vector replicator
    #    ci - inequalities for param use (ui%*%param-ci>=0)
    #    measvec,
    #    measinvvar,
    #    irmeas,
    #    fmn
    #    nb_sys - system sizes
    # Matrices:
    #    Afl, qrAfl, invAfl,
    #    p2bfl - helps to construct the rhs of flux system from free fluxes
    #    c2bfl - helps to construct the rhs of flux system from constr. fluxes
    #    mf, md, mc - help to construct fallnx
    #    mi - inequality matrix (ftbl content)
    #    ui - inequality matrix (ready for param use)
    #    measmat - measmat*(x[irmeas];1)=vec of simulated not-yet-scaled measures
    # Functions:
    #    param2fl_x - translate param to flux and cumomer vector (initial approximation)
    #    cumo_cost - cost function (khi2)
    #    cumo_grad - finite difference gradient
    #    fallnx2fwrv - produce fw-rv fluxes from fallnx

    # Main steps:
    #    python var init;
    #    R init;
    #    R function fallnx2fwrv();
    #    python measures, cumos, cumo2i;
    #    fortran code for cumomer systems A*x=b;
    #    R var init;
    #    R Afl, qr(Afl), invAfl;
    #    R param (without scale factors);
    #    R constrained fluxes
    #    R p2bfl, c2bfl, bp
    #    R mf, md, mc
    #    R mi, li
    #    python measure matrix, vector and vars
    #    R ui, ci
    #    R measure matrix, vector, vars
    #    R flux measures

    # header
    f.write("# This is an automatically generated R code. Don't edit.\n");
    f.write("# Generated by \n# "+join(" ", sys.argv)+"\n# at "+time.ctime()+".\n");
    f.write("""
# Copyright INRA, France.
""");
    #if DEBUG:
    #    pdb.set_trace();
    res={};
    f.write("""

# get some common tools
source("%(dirx)s/tools_ssg.R");
source("%(dirx)s/nlsic.R");
source("%(dirx)s/kvh.R");

# get runtime arguments
# argument proceeding by optparse package
suppressPackageStartupMessages(library("optparse"))

# specify our desired options in a list
# by default OptionParser will add an help option equivalent to 
# make_option(c("-h", "--help"), action="store_true", default=FALSE, 
#               help="Show this help message and exit")
option_list <- list(
   make_option("--version", default=F, action="store_true", dest="myver",
       help="show program's version number and exit"),
   make_option("--noopt", default=T, action="store_false", dest="optimize",
       help="no optimization, just use free fluxes as is, to calculate dependent fluxes, cumomers, stats and so on"),
   make_option("--noscale", default=F, action="store_true",
       help="no scaling factors to optimize => all scaling factors are 1"),
   make_option("--meth", default="nlsic", dest="method",
       help="method for optimization, one of BFGS|Nelder-Mead|ipopt|nlsic. Default: %%default"),
   make_option("--fullsys", default=F, action="store_true",
       help="calculate all cumomer set (not just the reduced one necesary to simulate measurements)"),
   make_option("--irand", default=F, action="store_true", dest="initrand",
       help="ignore initial approximation from FTBL file and use random values instead"),
   make_option("--sens", default="", metavar="mc=N", dest="sensitive",
       help="sensitivity method: mc=N, mc stands for Monte-Carlo. N is the number of Monte-Carlo simulations. Default: 10"),
   make_option("--cupx", default=0.999, type="double",
       help="upper limit for reverse fluxes. Must be in interval [0, 1]"),
   make_option("--cupn", default=1.e3, type="double",
       help="upper limit for net fluxes"),
   make_option("--clownr", default=0, type="double",
       help="lower limit for not reversible free and dependent fluxes. Zero value means no lower limit"),
   make_option("--cinout", default=0, type="double",
       help="lower limit for input/output free and dependent fluxes. Must be non negative"),
   make_option("--np", default=0, type="integer",
       help="Number of parallel process used in Monte-Carlo simulations
       Without this option or for NP=0 all available cores in a given node are used"),
   make_option("--ln", default=F, action="store_true", dest="least_norm",
       help="Least norm solution is proposed when Jacobian is rank deficient"),
   make_option("--zc", default=-.Machine$double.xmax, type="double",
       help="Apply zero crossing strategy with non negative threshold for net fluxes"),
   make_option("--DEBUG", default=F, action="store_true",
       help="developer option"),
   make_option("--TIMEIT", default=F, action="store_true",
       help="developer option"),
   make_option("--prof", default=F, action="store_true",
       help="developer option")
)
#opt=parse_args(OptionParser(option_list=option_list), args=strsplit("--sens mc=10", " ")[[1]])
if (!length(find("opt"))) {
   opt <- parse_args(OptionParser(option_list=option_list))
}
#print(opt)
attach(opt, warn=F)
vernum="%(vernum)s"
if (myver) {
   cat("%(prog)s %(vernum)s\\n")
   q("no")
}
# sanity check for command line parameters
if (substring(sensitive, 1, 3)=="mc=") {
   # read the mc iteration number
   nmc=as.integer(substring(sensitive, 4));
   sensitive="mc";
} else if (sensitive=="mc") {
   nmc=10;
}
# cupx==0 means no upper limit => cupx=1
cupx=ifelse(cupx, cupx, 1);
if (cupx < 0 || cupx > 1) {
   stop(paste("Option '--cupx N' must have N in the interval [0,1]\n",
      "Instead, the value ", cupx, " si given.", sep=""));
}
if (cinout < 0) {
   stop(paste("Option '--cinout N' must have N non negative\n",
      "Instead, the value ", cinout, " si given.", sep=""));
}
# minimization method
validmethods=list("BFGS", "Nelder-Mead", "SANN", "ipopt", "nlsic");
if (! method %%in%% validmethods) {
   warning(paste("method", method, "is not known. 'nlsic' is used instead."));
   method="nlsic";
}
if ( method == "ipopt") {
   installed=suppressPackageStartupMessages(library(ipoptr, logical.return=T));
}

if (np) {
   options(cores=np);
}
lsi_fun=lsi
if (least_norm) {
   lsi_fun=lsi_ln
}
if (zc==-.Machine$double.xmax) {
   # no zero scrossing to apply
   zerocross=F
} else {
   if (zc < 0.) {
      stop(paste("Zero crossing value ZC must be non negative, instead ", zc, " is given.", sep=""))
   }
   zerocross=T
}
opts=commandArgs()
# end command line argument proceeding

# get some cumomer tools
source("%(dirx)s/opt_cumo_tools.R");
dyn.load("%(dirx)s/cumo.%(so)s");
if (TIMEIT) {
   cat("rinit   : ", date(), "\n", sep="");
}

# R profiling
if (prof) {
   Rprof("%(proffile)s");
}

# input cumomer vector
xi=c(%(xi)s);
nm_xi=c(%(nm_xi)s);
nb_xi=length(xi);
"""%{
    "xi": join(", ", netan["cumo_input"].values()),
    "nm_xi": join(", ", netan["cumo_input"].keys(), '"', '"'),
#        "sofile": escape(os.path.basename(ff.name)[:-1]+
#            ("dll" if platform.system() == "windows" else "so"), "\\"),
    "dirx": escape(dirx, "\\"),
    "proffile": escape(os.path.basename(f.name)[:-1]+"Rprof", "\\"),
    "so": ("dll" if sys.platform in ("win32","cygwin") else "dylib" if sys.platform == "darwin" else "so"),
    "prog": os.path.basename(f.name),
    "vernum": file(os.path.join(dirx, "influx_version.txt"), "r").read().strip(),
});
    netan2R_fl(netan, org, f);
    d=netan2R_rcumo(netan, org, f);
    res.update(d);
    netan["rcumo_sys"]=res["rAb"];
    if fullsys:
        d=netan2R_cumo(netan, org, f);
        res.update(d);
    d=netan2R_meas(netan, org, f);
    res.update(d);
    netan2R_ineq(netan, org, f);
    f.write("""
nb_sys=list(
   reactions=list(
      reversible=%(rrev)s,
      non_reversible=%(rnonrev)s
   ),
   fluxes=list(
      free=%(ff)s,
      dependent=%(fd)s,
      constrained=%(fc)s
   ),
   metabolites=list(
      input=%(minp)s,
      output=%(moutp)s,
      intra=%(mintra)s
   ),
   measurements=list(
      flux=%(meas_f)s,
      mass=%(meas_m)s,
      peak=%(meas_p)s,
      label=%(meas_l)s
   ),
   equations=list(
      equalities=%(eqe)s,
      inequalities=%(eqi)s
   ),
   cumomer=list(
      full=c(%(lncumo)s),
      reduced=c(%(lnrcumo)s)
   )
);
# carbon length of metabolites
clen=c(%(clen)s);
names(clen)=c(%(nm_metab)s);
"""%{
    "rrev": len(netan["reac"])-len(netan["notrev"]),
    "rnonrev": len(netan["notrev"]),
    "ff": len(netan["flux_free"]["net"])+len(netan["flux_free"]["xch"]),
    "fd": len(netan["vflux"]["net"])+len(netan["vflux"]["xch"]),
    "fc": len(netan["vflux_constr"]["net"])+len(netan["vflux_constr"]["xch"]),
    "minp": len(netan["input"]),
    "moutp": len(netan["output"]),
    "mintra": len(netan["metabs"])-len(netan["input"])-len(netan["output"]),
    "meas_f": len(netan["vflux_meas"]["net"]),
    "meas_m": len(netan["measures"]["mass"]["vec"]),
    "meas_p": len(netan["measures"]["peak"]["vec"]),
    "meas_l": len(netan["measures"]["label"]["vec"]),
    "eqe": len(netan["flux_equal"]["net"])+len(netan["flux_equal"]["xch"]),
    "eqi": len(netan["flux_inequal"]["net"])+len(netan["flux_inequal"]["xch"]),
    "lncumo": ",".join(str(len(a)) for a in netan["cumo_sys"]["A"]),
    "lnrcumo": ",".join(str(len(a)) for a in netan["rcumo_sys"]["A"]),
    
    "clen": join(",", netan["Clen"].values()),
    "nm_metab": join(",", netan["Clen"].keys(), '"', '"')
    });
    return res;

def netan2R_fl(netan, org, f):
    """netan2R_fl(netan, org, f)
    generate R code for flux part
    for more details cf. netan2Rinit()
    """
    # dependent flux counts
    nb_fln=len(netan['vflux']['net']);
    nb_flx=len(netan['vflux']['xch']);
    nb_fl=nb_fln+nb_flx;

    # prepare index translator for free fluxes
    # it will be used in bfl expressions where names like flx.net must
    # be mapped on respecting parameter index
    nb_ffn=len(netan['flux_free']['net']);
    nb_ffx=len(netan['flux_free']['xch']);
    nb_fcn=len(netan['flux_constr']['net']);
    nb_fcx=len(netan['flux_constr']['xch']);
    ffn2iprm=dict(("f.n."+f,(i+1))
        for (f,i) in netan['vflux_free']['net2i'].iteritems());
    ffx2iprm=dict(("f.x."+f,(i+1+nb_ffn))
        for (f,i) in netan['vflux_free']['xch2i'].iteritems());

    # prepare fwrv2i
    fwrv2i=dict((f,i+1) for (f,i) in netan["vflux_fwrv"]["fwrv2i"].iteritems());
    nb_fwrv=len(netan["vflux_fwrv"]["fwrv2i"]);

    # make tuple for complete flux vector d,f,c
    # (name,"d|f|c","n|x")
    tfallnx=zip(
            netan["vflux"]["net"]+
            netan["vflux_free"]["net"]+
            netan["vflux_constr"]["net"]+
            netan["vflux"]["xch"]+
            netan["vflux_free"]["xch"]+
            netan["vflux_constr"]["xch"],

            ["d"]*len(netan["vflux"]["net"])+
            ["f"]*len(netan["vflux_free"]["net"])+
            ["c"]*len(netan["vflux_constr"]["net"])+
            ["d"]*len(netan["vflux"]["xch"])+
            ["f"]*len(netan["vflux_free"]["xch"])+
            ["c"]*len(netan["vflux_constr"]["xch"]),

            ["n"]*len(netan["vflux"]["net"])+
            ["n"]*len(netan["vflux_free"]["net"])+
            ["n"]*len(netan["vflux_constr"]["net"])+
            ["x"]*len(netan["vflux"]["xch"])+
            ["x"]*len(netan["vflux_free"]["xch"])+
            ["x"]*len(netan["vflux_constr"]["xch"]),
            );
    netan["f2dfc_nx_f"]={
       "net": dict((fl, t+".n."+fl) for (fl,t,nx) in tfallnx if nx=="n"),
       "xch": dict((fl, t+".x."+fl) for (fl,t,nx) in tfallnx if nx=="x"),
    };

    f.write("""
if (TIMEIT) {
   cat("r_flux  : ", date(), "\n", sep="");
}

# custom functions
# produce fw-rv fluxes from fallnx
fallnx2fwrv=function(fallnx) {
   n=length(fallnx);
   # extract and reorder in fwrv order
   net=fallnx[c(%(inet2ifwrv)s)];
   xch=fallnx[c(%(ixch2ifwrv)s)];
   # expansion 0;1 -> 0;+inf of xch (second half of fallnx)
   xch=xch/(1-xch);
   # fw=xch-min(-net,0)
   # rv=xch-min(net,0)
   fwrv=c(xch-pmin(-net,0),xch-pmin(net,0));
   if (DEBUG) {
      n=length(fwrv);
      library(MASS);
      names(fwrv)=nm_fwrv
      write.matrix(fwrv, file="dbg_fwrv.txt", sep="\\t");
   }
   return(fwrv);
}
""" % {
#dyn.load("%(sofile)s");
        "inet2ifwrv": join(", ", (1+
        (netan["vflux"]["net2i"][fl[4:]] if fl[4:] in netan["vflux"]["net2i"]
        else nb_fln+netan["vflux_free"]["net2i"][fl[4:]] if fl[4:] in netan["vflux_free"]["net2i"]
        else nb_fln+nb_ffn+netan["vflux_constr"]["net2i"][fl[4:]])
        for fl in netan["vflux_fwrv"]["fwrv"][:nb_fwrv/2])),
        "ixch2ifwrv": join(", ", (1+len(netan["vflux_fwrv"]["fwrv"])/2+
        (netan["vflux"]["xch2i"][fl[4:]] if fl[4:] in netan["vflux"]["xch2i"]
        else nb_flx+netan["vflux_free"]["xch2i"][fl[4:]] if fl[4:] in netan["vflux_free"]["xch2i"]
        else nb_flx+nb_ffx+netan["vflux_constr"]["xch2i"][fl[4:]])
        for fl in netan["vflux_fwrv"]["fwrv"][:nb_fwrv/2])),
    });
    # auxiliary dict for edge-flux coupling
    f2edge=dict();
    for (fl,lr) in netan["sto_r_m"].iteritems():
        if len(lr["left"])==1 and len(lr["right"])==1:
           f2edge[fl]=[lr["left"][0]+" ("+fl+") "+lr["right"][0]];
        else:
           f2edge[fl]=[]
           for m in lr["left"]:
               f2edge[fl].append(m+" ("+fl+") "+fl);
           for m in lr["right"]:
               f2edge[fl].append(fl+" ("+fl+") "+m);
    #sys.stderr.write(str(f2edge)+"\n");
    #sys.stderr.write(str(netan["f2dfc_nx_f"]["net"])+"\n");
    f.write("""
# fwd-rev flux names
nm_fwrv=c(%(nm_fwrv)s);

# net-xch flux names
nm_fallnx=c(%(nm_fallnx)s);

# edge to netflux name translator
edge2fl=c(%(edge2fl)s);

# initialize the linear system Afl*flnx=bfl (0-weight cumomers)
# unknown net flux names
nm_fln=c(%(nm_fln)s);
nb_fln=length(nm_fln);
# unknown xch flux names
nm_flx=c(%(nm_flx)s);
nb_flx=length(nm_flx);
nm_fl=c(nm_fln, nm_flx);
nb_fl=nb_fln+nb_flx;
# gather flux names in a list
nm_list=list(flnx=nm_fl, fallnx=nm_fallnx, fwrv=nm_fwrv);
# flux matrix
nb_flr=%(nb_flr)d;
if (nb_fl) {
   Afl=matrix(0, nrow=nb_flr, ncol=nb_fl);
"""%{
    "nb_flr": len(netan["Afl"]),
    "nm_fwrv": join(", ", netan["vflux_fwrv"]["fwrv"], '"', '"'),
    "nm_fallnx": join(", ", (join(".", (t[1],t[2],t[0])) for t in tfallnx), '"', '"'),
    "nm_fln": join(", ", netan["vflux"]["net"], '"d.n.', '"'),
    "nm_flx": join(", ", netan["vflux"]["xch"], '"d.x.', '"'),
    "edge2fl": join(", ", ('"'+e+'"="'+netan["f2dfc_nx_f"]["net"][fl]+'"' for (fl,l) in f2edge.iteritems() for e in l)),
});
    for (i,row) in enumerate(netan["Afl"]):
        f.write(
"""   Afl[%(i)d, c(%(ic)s)]=c(%(v)s);
"""%{
    "i": i+1,
    "ic": join(", ", (i+1 for (i,v) in enumerate(row) if v!=0.)),
    "v": join(", ", (v for v in row if v!=0.)),
});
    f.write(
"""} else {
   Afl=matrix(0., nb_fl, nb_fl);
}
dimnames(Afl)=list(c(%(nm_rows)s), nm_fl);
if (DEBUG) {
   library(MASS);
   write.matrix(Afl, file="dbg_Afl.txt", sep="\\t");
}
# prepare param (\Theta) vector
# order: free flux net, free flux xch, scale label, scale mass, scale peak
param=numeric(0);
nm_par=c();
# free net fluxes
nb_ffn=%(nb_ffn)d;
nm_ffn=c(%(nm_ffn)s);
# starting values for iterations
param=c(param, c(%(ffn)s));
if (nb_ffn) {
   nm_par=c(nm_par, nm_ffn);
}
# free xch fluxes
nb_ffx=%(nb_ffx)d;
nm_ffx=c(%(nm_ffx)s);
# starting values for iterations
param=c(param, c(%(ffx)s));
if (nb_ffx) {
   nm_par=c(nm_par, nm_ffx);
}
nm_ff=c(nm_ffn, nm_ffx);
nb_param=length(param);
if (initrand) {
   param=runif(nb_param);
}
# scaling factors are added to param later

nb_ff=nb_ffn+nb_ffx;
# constrained fluxes
# net
nb_fcn=%(nb_fcn)d;
nm_fcn=c(%(nm_fcn)s);
fcn=c(%(fcn)s);
# xch
nb_fcx=%(nb_fcx)d;
nm_fcx=c(%(nm_fcx)s);
fcx=c(%(fcx)s);
fc=c(fcn, fcx);
nm_fc=c(nm_fcn, nm_fcx)
names(fc)=nm_fc;
nb_fc=nb_fcn+nb_fcx;

# total flux vector fallnx dimension
nb_fallnx=nb_fl+nb_ff+nb_fc;

# all flux cardinals
nb_f=list(nb_fln=nb_fln, nb_flx=nb_flx, nb_fl=nb_fl,
   nb_ffn=nb_ffn, nb_ffx=nb_ffx, nb_ff=nb_ff,
   nb_fcn=nb_fcn, nb_fcx=nb_fcx, nb_fc=nb_fc,
   nb_fallnx=nb_fallnx);
"""%{
    "nm_rows": join(", ", netan["vrowAfl"], '"', '"'),
    "nb_ffn": nb_ffn,
    "nb_ffx": nb_ffx,
    "nm_ffn": join(", ", netan["vflux_free"]["net"], '"f.n.', '"'),
    "nm_ffx": join(", ", netan["vflux_free"]["xch"], '"f.x.', '"'),
    "ffn": join(", ", [netan["flux_free"]["net"][fl]
        for fl in netan["vflux_free"]["net"]]),
    "ffx": join(", ", [netan["flux_free"]["xch"][fl]
        for fl in netan["vflux_free"]["xch"]]),
    "nb_fcn": len(netan["flux_constr"]["net"]),
    "nb_fcx": len(netan["flux_constr"]["xch"]),
    "nm_fcn": join(", ", netan["vflux_constr"]["net"], '"c.n.', '"'),
    "nm_fcx": join(", ", netan["vflux_constr"]["xch"], '"c.x.', '"'),
    "fcn": join(", ", [netan["flux_constr"]["net"][fl]
        for fl in netan["vflux_constr"]["net"]]),
    "fcx": join(", ", [netan["flux_constr"]["xch"][fl]
        for fl in netan["vflux_constr"]["xch"]]),
});
    f.write("""
# prepare p2bfl, c2bfl, cnst2bfl matrices such that p2bfl%*%param[1:nb_ff]+
# c2bfl%*%fc+cnst2bfl=bfl
# replace f.[nx].flx by corresponding param coefficient
p2bfl=matrix(0., nrow=nb_flr, ncol=nb_ff);
# replace c.[nx].flx by corresponding fc coefficient
c2bfl=matrix(0., nrow=nb_flr, ncol=nb_fc);
cnst2bfl=numeric(nb_flr); # can come from equalities
colnames(p2bfl)=nm_par;
colnames(c2bfl)=nm_fc;
""");
    for (i,item) in enumerate(netan["bfl"]):
        if not item:
            continue;
        f.write("\
p2bfl[%(i)d, c(%(if)s)]=c(%(row)s);\n\
c2bfl[%(i)d, c(%(ic)s)]=c(%(rowc)s);\n\
cnst2bfl[%(i)d]=%(rowcnst)s;\n\
"%{
        "i": i+1,
        "if": join(", ", (k for k in item.keys() if k[0:2]=="f."), p='"', s='"'),
        "row": join(", ", (v for (k,v) in item.iteritems() if k[0:2]=="f.")),
        "ic": join(", ", (k for k in item.keys() if k[0:2]=="c."), p='"', s='"'),
        "rowc": join(", ", (v for (k,v) in item.iteritems() if k[0:2]=="c.")),
        "rowcnst": item.get("", 0.),
        });
    f.write("""
bp=c2bfl%*%fc+cnst2bfl;
""");

    f.write("""
qrAfl=qr(Afl, LAPACK=T);
d=diag(qrAfl$qr);
qrAfl$rank=sum(abs(d)>=abs(d[1]*1.e-10))
#browser()
if (nrow(Afl) != ncol(Afl)) {
   #write.table(Afl);
   if (nrow(Afl) < ncol(Afl)) {
      mes=paste("Candidate(s) for free flux(es):\\n",
         paste(colnames(Afl)[-qrAfl$pivot[1:nrow(Afl)]], collapse="\\n"), sep="");
   } else {
      nextra=nrow(Afl)-ncol(Afl)
      comb=combn(nb_ffn, nextra)
      i=which.min(apply(comb, 2, function(i)kappa(cbind(Afl, p2bfl[i]))))[1]
      ka=kappa(cbind(Afl, p2bfl[i]))
      if (ka!=Inf) {
         prop=paste("Proposal to delcare dependent flux(es) is:\\n",
            paste(nm_ffn[i], collapse="\\n"), sep="")
      } else {
         # test constraint candidate
         comb=combn(nb_fcn, nextra)
         i=which.min(apply(comb, 2, function(i)kappa(cbind(Afl, c2bfl[i]))))[1]
         ka=kappa(cbind(Afl, c2bfl[i]))
         if (ka!=Inf) {
            prop=paste("Proposal to delcare dependent flux(es) is:\\n",
            paste(nm_fcn[i], collapse="\\n"), sep="")
         } else {
            prop="No proposal for dependent fluxes could be made."
         }
      }
      mes=paste("There is (are) probably ", nextra,
         " extra free flux(es) among the following:\\n",
         paste(nm_ffn, collapse="\\n"), "\\n",
         prop,
         "\\nAnother option could be an elimination of some equalities.",
         sep="");
   }
   stop(paste("Flux matrix is not square: (", nrow(Afl), "eq x ", ncol(Afl), "unk)\\n",
      "You have to change your choice of free fluxes in the '%(n_ftbl)s' file.\\n",
      mes, sep=""));
}

# make sure that free params choice leads to not singular matrix
if (qrAfl$rank != nb_fl) {
   #write.table(Afl);
   # make a suggestion of new free fluxes
   A=cbind(Afl, -p2bfl, -c2bfl)
   colnames(A)=c(colnames(Afl), nm_ff, nm_fc)
   qa=qr(A, LAPACK=T)
   d=diag(qa$qr);
   qa$rank=sum(abs(d)>=abs(d[1]*1.e-10))
   
   mes=paste("Dependent flux matrix is singular.\\n",
      "Change your partition on free/dependent/constrained fluxes in the '%(n_ftbl)s' file.\\n",
      "Can not resolve dependent fluxe(s):\\n",
      paste(colnames(Afl)[-qrAfl$pivot[(1:qrAfl$rank)]], collapse="\\n"),
      sep="")
   if (qa$rank==nb_fl) {
      mes=paste(mes,
      "\\n\\nSuggested dependent fluxes:\\n",
      paste(colnames(A)[qa$pivot[(1:qa$rank)]], collapse="\\n"),
      "\\n\\nWhich would give the following free and constrained fluxes:\\n",
      paste(colnames(A)[-qa$pivot[(1:qa$rank)]], collapse="\\n"), "\\n",
      sep="");
   } else {
      mes=paste(mes, "\\nNo suggested free fluxes could be found", sep="")
   }
   cat(mes);
   stop(mes);
}

# inverse flux matrix
invAfl=solve(qrAfl);

""" % {
    "n_ftbl": escape(org+".ftbl", "\\"),
    });
    f.write("""
# intermediate jacobian
dfl_dff=invAfl %*% p2bfl
dimnames(dfl_dff)=list(nm_fl, nm_ff)

# prepare mf, md matrices and bd vector
# such that mf%*%ff+md%*%fl+mc%*%fc gives fallnx
# here ff free fluxes (param), fl are dependent fluxes and fc are constrained
# fluxes
mf=matrix(0., nb_fallnx, nb_ff);
dimnames(mf)=list(nm_fallnx, nm_ff);
md=matrix(0., nb_fallnx, nb_fl);
dimnames(md)=list(nm_fallnx, nm_fl);
mc=matrix(0., nb_fallnx, nb_fc);
dimnames(mc)=list(nm_fallnx, nm_fc);

mf[nm_ff, nm_ff]=diag(1., nb_ff);
md[nm_fl, nm_fl]=diag(1., nb_fl);
mc[nm_fc, nm_fc]=diag(1., nb_fc);
""");
    netan["fwrv2i"]=fwrv2i;
    netan["tfallnx"]=tfallnx;

def netan2R_meas(netan, org, f):
    """netan2R_meas(netan, org, f)
    generate code for measure treatment
    """
    # prepare python measures
    if "measures" not in netan:
        print("Calculate measures in netan2R_meas.");
        measures=dict();
        for meas in ("label", "mass", "peak"):
            measures[meas]=eval("C13_ftbl.%s_meas2matrix_vec_dev(netan)"%meas);
        netan["measures"]=measures;
    measures=netan["measures"];
    #aff("got measures in netan2R_meas", measures);##
    # get scaling factors and their indexes, measure matrices, and measured cumomer value vector
    scale={"label": {}, "mass": {}, "peak": {}}; # for unique scale names
    nrow={"label": {}, "mass": {}, "peak": {}}; # for counting scale names
    o_sc={"label": {}, "mass": {}, "peak": {}}; # for ordered unique scale names
    o_meas=measures.keys(); # ordered measure types
    o_meas.sort();

    if DEBUG:
        pdb.set_trace();

    ir2isc={"label": [], "mass": [], "peak": []}; # for mapping measure rows indexes on scale index
    # we want to use it in python like isc[meas]=ir2isc[meas][ir]
    for meas in o_meas:
        # get unique scaling factors
        # and count rows in each group
        # row["scale"] is "metab;group" (metab name may be fake here)
        for (i,row) in enumerate(measures[meas]["mat"]):
            scale[meas][row["scale"]]=0.;
            nrow[meas][row["scale"]]=nrow[meas].get(row["scale"],0.)+1;
        # remove groups having only one measure in them
        for (k,n) in list(nrow[meas].iteritems()):
            if n<2:
                del(scale[meas][k]);
        # order scaling factor
        o_sc[meas]=scale[meas].keys();
        o_sc[meas].sort();
        # map a measure rows (card:n) on corresponding scaling factor (card:1)
        # if a row has not scale factor it is scaled with factor 1
        # vector having scaling parameters is formed like
        # c(1,param);
        ir2isc[meas]=[-1]*len(measures[meas]["mat"]);
        for (i,row) in enumerate(measures[meas]["mat"]):
            if row["scale"] in scale[meas]:
                ir2isc[meas][i]=o_sc[meas].index(row["scale"]);

        # measured value vector is in measures[meas]["vec"]
        # measured dev vector is in measures[meas]["dev"]

    if DEBUG:
        pdb.set_trace();

    # create R equivalent structures with indices for scaling
    f.write("""
if (TIMEIT) {
   cat("measure : ", date(), "\n", sep="");
}
# make place for scaling factors
""");
    for meas in o_meas:
        if not o_sc[meas]:
            continue;
        f.write("""
# %(meas)s
# initial values for scales are set later
param=c(param,%(sc)s);
nm_par=c(nm_par,c(%(sc_names)s));
""" % {
        "meas": meas,
        "sc": join(", ", (scale[meas][sc] for sc in o_sc[meas])),
        "sc_names": join(", ", o_sc[meas], '"'+meas+';', '"'),
        });

    f.write("""
nb_param=length(param);
nb_sc=nb_param-nb_ff;
# indices mapping from scaling to measure matrix row
# c(1,par)[ir2isc] replicates scale parameters
# for corresponding rows of measure matrix
ir2isc=numeric(0);
""");
    base_isc=1;
    for meas in o_meas:
        f.write("""
# %(meas)s
ir2isc=c(ir2isc,c(%(ir2isc)s));
""" % {
        "nsc_meas": len(scale[meas]),
        "meas": meas,
        "sc_names": join(", ", o_sc[meas], '"', '"'),
        "ir2isc": join(", ", ((str(ir2isc[meas][ir]+base_isc) if ir2isc[meas][ir]>=0 else -1)
            for ir in xrange(len(ir2isc[meas]))))
        });
        base_isc=base_isc+len(scale[meas]);

    f.write("""
# shift indices by nb_ff+1
ir2isc[ir2isc>0]=ir2isc[ir2isc>0]+nb_ff+1;
ir2isc[ir2isc<=0]=1;

if (noscale) {
#browser();
   # remove scaling params from optimization
   param=param[1:nb_ff];
   nm_par=nm_par[1:nb_ff];
   nb_param=length(param);
   ir2isc[]=1;
   nb_sc=0;
}
""");
    # get the full dict of non zero cumomers involved in measures
    # cumo=metab:icumo where icumo is in [1;2^Clen]
    if DEBUG:
        pdb.set_trace();
    meas_cumos={};
    for meas in o_meas:
        for row in measures[meas]["mat"]:
            metab=row["metab"];
            meas_cumos.update((metab+":"+str(icumo), "") for icumo in row["coefs"].keys() if icumo != 0);

    # order involved cumomers
    o_mcumos=meas_cumos.keys();
    o_mcumos.sort();
    imcumo2i=dict((cumo, i) for (i, cumo) in enumerate(o_mcumos));
    nb_mcumo=len(o_mcumos);
    f.write("""
# make measure matrix
# matrix is "densified" such that
# measmat*(xr[irmeas];1) gives a vector of simulated not-yet-scaled measures
# where irmeas is the R-index of involved in measures cumomers
# all but 0. Coefficients of 0-cumomers (by defenition equal to 1)
# are all regrouped in the last matrix column.
nm_meas=c(%(idmeas)s);
nb_meas=length(nm_meas);
measmat=matrix(0., nb_meas, %(ncol)d);
measvec=c(%(vmeas)s);
measinvvar=c(%(invvar)s);
irmeas=c(%(irmeas)s);
nm_mcumo=c(%(mcumos)s);
dimnames(measmat)=list(nm_meas, c(nm_mcumo, "#x*"));
names(measvec)=nm_meas;
names(measinvvar)=nm_meas;
"""%{
    "nrow": len([measures[meas]["vec"] for meas in measures]),
    "ncol": (nb_mcumo+1),
    "irmeas": join(", ", trd(o_mcumos, netan["rcumo2i"], a="")),
    "mcumos": join(", ", o_mcumos, '"', '"'),
    "idmeas": join(", ", (row["id"] for row in
        valval(measures[o]["mat"] for o in o_meas)),
        p='"', s='"'),
    "vmeas": join(", ", valval(measures[o]["vec"] for o in o_meas)),
    "invvar": join(", ", (1./sd/sd for sd in valval(measures[o]["dev"]
        for o in o_meas))),
    });

    # get coeffs in the order above with their corresponding indices from total cumomer vector
    i=0;
    for meas in o_meas:
        if not measures[meas]["mat"]:
            continue;
        #print("meas="+meas+"; mat="+str(measures[meas]["mat"]));##
        for row in measures[meas]["mat"]:
            i+=1;
            metab=row["metab"];
            f.write(
"""measmat[%(i)d, c(%(cumos)s)]=c(%(coefs)s);
"""%{
    "i": i,
    "cumos": join(", ", ((metab+":"+str(k) if k else "#x*")
        for k in row["coefs"].keys()), p='"', s='"'),
    "coefs": join(", ", row["coefs"].values()),
});

    f.write("""
# prepare flux measures
nb_fmn=%(nb_fmn)d;
nm_fmn=c(%(nm_fmn)s);

# measured values
fmn=c(%(fmn)s);

# inverse of variance for flux measures
invfmnvar=c(%(invfmnvar)s);

# indices for measured fluxes
# fallnx[ifmn]=>fmn, here fallnx is complete net|xch flux vector
# combining unknown (dependent), free and constrainded fluxes
ifmn=c(%(ifmn)s);

"""%{
    "nb_fmn": len(netan["vflux_meas"]["net"]),
    "nm_fmn": join(", ", trd(("n."+f for f in netan["vflux_meas"]["net"]),
        netan["nx2dfc"]), '"', '"'),
    "fmn": join(", ", (netan["flux_measured"][fl]["val"]
        for fl in netan["vflux_meas"]["net"])),
    "invfmnvar": join(", ", (1./(netan["flux_measured"][fl]["dev"]**2)
        for fl in netan["vflux_meas"]["net"])),
    "ifmn": join(", ", (1+netan["vflux_compl"]["net2i"][fl]
        for fl in netan["vflux_meas"]["net"])),
    });
    return {
        "o_meas": o_meas,
        "measures": measures,
        "o_mcumos": o_mcumos,
        "imcumo2i": imcumo2i,
    };

def netan2R_rcumo(netan, org, f):
    # prepare reduced python systems
    rAb=C13_ftbl.rcumo_sys(netan);
    # full matrix is Ab=netan["cumo_sys"]

    # prune ordered cumomer list in reverse order
    # so that deleted item does not change the index
    # for the rest items to prune
    if "vrcumo" not in netan:
        netan["vrcumo"]=copy.deepcopy(netan["vcumo"]);
        for i in xrange(len(netan["vrcumo"]),len(rAb["A"]),-1):
            # delete extra weight systems
            del(netan["vrcumo"][i-1]);
        for (iw,cumol) in enumerate(netan["vrcumo"]):
            for i in xrange(len(cumol), 0, -1):
                i-=1;
                if cumol[i] not in rAb["A"][iw]:
                    #print "prune", i, cumol[i];##
                    del(cumol[i]);
    # prepare cumo2i
    # translate cumoname like A:7 to its index in R vector of cumomers
    rcumos=list(valval(netan["vrcumo"]));
    rcumo2i=dict((c,i+1) for (i,c) in enumerate(rcumos));
    # composit cumomer vector incu=c(1,xi,xc)
    incu2i_b1=dict((c,i+2) for (i,c) in enumerate(netan["cumo_input"].keys()+rcumos));
    # write code for reduced cumomer systems
    #netan2Abcumo_f(rAb["A"], rAb["b"],
    #    netan["vrcumo"], netan["input"], ff, netan["fwrv2i"], incu2i_b1, "fwrv2rAbcumo");
    #netan2Abcumo_sp("spAb_old", rAb["A"], rAb["b"],
    #    netan["vrcumo"], netan["input"], f, netan["fwrv2i"], incu2i_b1);
    netan2Abcumo_spr("spAbr", rAb["A"], rAb["b"],
        netan["vrcumo"], netan["input"], f, netan["fwrv2i"], incu2i_b1);
    #netan2j_rhs_f(rAb["A"], rAb["b"],
    #    netan["vrcumo"], netan["input"], ff, netan["fwrv2i"], rcumo2i, incu2i_b1, "frj_rhs");
    # write R constants and names
    f.write("""
# weight count
nb_rw=%(nb_rw)d;
# cumomer count by weight;
nb_rcumos=c(%(nb_rc)s);
# cumo names
nm_rcumo=c(%(nm_rcumo)s);
nm_list[["rcumo"]]=nm_rcumo;
# composite cumomer vector incu c(1, xi, xc) names
nm_incu=c("one", nm_xi, nm_rcumo); # the constant 1 has name "one"
"""%{
    "nb_rw": len(rAb["A"]),
    "nb_rc": join(", ", (len(a) for a in rAb["A"])),
    "nm_rcumo": join(", ", valval(netan['vrcumo']), '"', '"'),
});
    netan["rcumo2i"]=rcumo2i;
    return {
        "rcumo2i": rcumo2i,
        "rAb": rAb,
    };

def netan2R_cumo(netan, org, f):
    """netan2R_cumo(netan, org, f)->dict
    generate fortran code for matrices
    """
    # prepare cumo2i
    # translate cumoname like A:7 to its index in R vector of cumomers
    cumos=list(valval(netan["vcumo"]));
    cumo2i=dict((c,i+1) for (i,c) in enumerate(cumos));
    # composite cumomer vector
    incu2i_b1=dict((c,i+2) for (i,c) in enumerate(netan["cumo_input"].keys()+cumos));

    # write sparse matrix code for complete cumomer systems
    #netan2Abcumo_f(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
    #    netan["vcumo"], netan["input"], ff, netan["fwrv2i"], cumo2i, incu2i_b1, "fwrv2Abcumo");
    #netan2j_rhs_f(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
    #    netan["vcumo"], netan["input"], ff, netan["fwrv2i"], cumo2i, incu2i_b1, "fj_rhs");
    netan2Abcumo_spr("spAbr_f", netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
        netan["vcumo"], netan["input"], f, netan["fwrv2i"], incu2i_b1);
    # write R constants and names
    f.write("""
if (TIMEIT) {
   cat("cumo   : ", date(), "\n", sep="");
}

# weight count
nb_w=%(nb_w)d;

# cumomer count by weight;
nb_cumos=c(%(nb_c)s);

# cumo names
nm_cumo=c(%(nm_cumo)s);
"""%{
    "nb_w": len(netan["cumo_sys"]["A"]),
    "nb_c": join(", ", (len(a) for a in netan["cumo_sys"]["A"])),
    "nm_cumo": join(", ", valval(netan['vcumo']), '"', '"'),
});
    netan["cumo2i"]=cumo2i;
    return {
        "cumo2i": cumo2i,
    };

def netan2R_ineq(netan, org, f):
    """netan2R_ineq(netan, org, f)
    generate inequality code
    """
    # ex: netan["flux_inequal"]
    # {'net': [], 'xch': [('0.85', '>=', {'v2': '+1.'})]}
    tfallnx=netan["tfallnx"];
    f2dfc_nx_f=netan["f2dfc_nx_f"];
    #dict2kvh(dict((i,t) for (i,t) in enumerate(tfallnx)), "tfallnx.kvh");##
    nb_ineq=len(netan["flux_inequal"]["net"])+len(netan["flux_inequal"]["xch"]);
    f.write("""
if (TIMEIT) {
   cat("ineq    : ", date(), "\n", sep="");
}
fallnx=param2fl(param, nb_f, nm_list, invAfl, p2bfl, bp, fc)$fallnx
# prepare mi matrix and li vector
# such that mi*fallnx>=li corresponds
# to the inequalities given in ftbl file
nb_ineq=%(nb_ineq)s;
mi=matrix(0., nrow=nb_ineq, ncol=nb_fallnx);
li=numeric(nb_ineq);
nm_i=c(c(%(nm_in)s), c(%(nm_ix)s));
dimnames(mi)=list(nm_i, nm_fallnx);
""" % {
   "nb_ineq": nb_ineq,
   "nm_in": join(", ", (join("", (ineq[0], ineq[1], join("+",
        ((str(fa)+"*" if fa != 1. else "")+fl
        for (fl,fa) in ineq[2].iteritems()))))
        for ineq in netan["flux_inequal"]["net"]), p='"n:', s='"'),
   "nm_ix": join(", ", (join("", (ineq[0], ineq[1], join("+",
        ((str(fa)+"*" if fa != 1. else "")+fl
        for (fl,fa) in ineq[2].iteritems()))))
        for ineq in netan["flux_inequal"]["xch"]), p='"x:', s='"'),
});
    
    for (i, ineq) in enumerate(netan["flux_inequal"]["net"]):
        f.write(
"""mi[%(i)s, c(%(f)s)]=%(sign)sc(%(coef)s);
li[%(i)s]=%(sign)s%(li)g;
"""%{
    # as R inequality is always ">=" we have to inverse the sign for "<=" in ftbl
    "i": i+1,
    "sign": ("" if ineq[1]=="<=" or ineq[1]=="=<" else "-"),
    "f": join(", ", trd(ineq[2].keys(), f2dfc_nx_f["net"]), p='"', s='"'),
    "coef": join(", ", ineq[2].values()),
    "li": ineq[0],
    });
    for (i, ineq) in enumerate(netan["flux_inequal"]["xch"]):
        f.write(
"""mi[%(i)s, c(%(f)s)]=%(sign)sc(%(coef)s);
li[%(i)s]=%(sign)s%(li)g;
"""%{
    # as R inequality is always ">=" we have to inverse the sign for "<=" in ftbl
    "i": len(netan["flux_inequal"]["net"])+i+1,
    "sign": ("" if ineq[1]=="<=" or ineq[1]=="=<" else "-"),
    "f": join(", ", trd(ineq[2].keys(), f2dfc_nx_f["xch"]), p='"', s='"'),
    "coef": join(", ", ineq[2].values()),
    "li": ineq[0],
    });

    nb_fdx=len(netan["vflux"]["xch"]);
    nb_ffx=len(netan["vflux_free"]["xch"]);
    f.write("""
# add standard limits on [df].xch [0;cupx]
nb_tmp=nrow(mi);
nb_fx=nb_flx+nb_ffx;
if (nb_fx) {
   mi=rbind(mi, matrix(0, nrow=2*nb_fx, ncol=nb_fallnx));
   if (nb_flx)
      nm_i=c(nm_i, paste(nm_flx, ">=0", sep=""));
   if (nb_ffx)
      nm_i=c(nm_i, paste(nm_ffx, ">=0", sep=""));
   if (nb_flx)
      nm_i=c(nm_i, paste(nm_flx, "<=", cupx, sep=""));
   if (nb_ffx)
      nm_i=c(nm_i, paste(nm_ffx, "<=", cupx, sep=""));
   li=c(li, rep(0, nb_fx), rep(-cupx, nb_fx));
   mi[nb_tmp+(1:nb_fx),c(nm_flx, nm_ffx)]=diag(1., nb_fx);
   mi[nb_tmp+nb_fx+(1:nb_fx),c(nm_flx, nm_ffx)]=diag(-1., nb_fx);
}
""");
    
    nb_notrev=len(netan["notrev"]);
    f.write("""
nb_inout=%(nb_inout)d
if (nb_inout > 0) {
   # add cinout low limits on inout net fluxes
   nb_tmp=nrow(mi);
   nm_inout=c(%(nm_inout)s);
   mi=rbind(mi, matrix(0, nrow=nb_inout, ncol=nb_fallnx));
   nm_i=c(nm_i, paste("inout ", nm_inout, ">=", cinout, sep=""));
   mi[nb_tmp+(1:nb_inout), nm_inout]=diag(1., nb_inout);
   li=c(li, rep(cinout, nb_inout));
}
if (clownr!=0.) {
   # add low limits on net >= clownr for not reversible reactions
   nb_tmp=nrow(mi);
   nm_tmp=c(%(nm_notrev)s);
   mi=rbind(mi, matrix(0, nrow=%(nb_notrev)d, ncol=nb_fallnx));
   nm_i=c(nm_i, paste(nm_tmp, ">=", clownr));
   mi[nb_tmp+(1:%(nb_notrev)d), nm_tmp]=diag(1., %(nb_notrev)d);
   li=c(li, rep(clownr, %(nb_notrev)d));
}
nb_fn=nb_fln+nb_ffn
if (cupn != 0 && nb_fn) {
   # add upper limits on [df].net <= cupn for net fluxes
   nb_tmp=nrow(mi);
   mi=rbind(mi, matrix(0, nrow=nb_fn, ncol=nb_fallnx));
   if (nb_fln)
      nm_i=c(nm_i, paste(nm_fln, "<=", cupn, sep=""));
   if (nb_ffn)
      nm_i=c(nm_i, paste(nm_ffn, "<=", cupn, sep=""));
   li=c(li, rep(-cupn, nb_fn));
   mi[nb_tmp+(1:nb_fn),c(nm_fln, nm_ffn)]=diag(-1., nb_fn);
}

"""%{
   "nb_notrev": len([fli for (fli,t,nxi) in tfallnx
      if nxi=="n" and t!="c" and fli in netan["notrev"]]),
   "nm_notrev": join(", ", (t+"."+nxi+"."+fli
      for (fli,t,nxi) in tfallnx
      if nxi=="n" and t!="c" and fli in netan["notrev"]),
      p='"', s='"'),
   "nb_inout": len([fli for (fli,t,nxi) in tfallnx
      if nxi=="n" and t!="c" and fli in netan["flux_inout"]]),
   "nm_inout": join(", ", (t+"."+nxi+"."+fli
      for (fli,t,nxi) in tfallnx
      if nxi=="n" and t!="c" and fli in netan["flux_inout"]),
      p='"', s='"'),
});

    f.write("nb_ineq=NROW(li);\n");
    f.write("""
dimnames(mi)=list(nm_i, nm_fallnx);
names(li)=nm_i;
# prepare ui matrix and ci vector for optimisation
# ui%*%param-ci>=0
# it is composed of explicite inequalities from ftbl
# and permanent inequalities 0<=xch<=0.999 and scale>=0

# constraints such that ui%*%param[1:nb_ff]-ci>=0
ui=mi%*%(md%*%invAfl%*%p2bfl+mf);
mic=(md%*%invAfl%*%(c2bfl%*%fc+cnst2bfl) + mc%*%fc)
ci=li-mi%*%mic;
#browser()
# remove all zero rows in ui (constrained fluxes with fixed values)
# find zero indexes
#print(dim(ui))
if (ncol(ui)) {
   zi=apply(ui,1,function(v){return(max(abs(v))<=1.e-14)});
} else {
   zi=rep(FALSE, nrow(ui))
}

if (all(ci[zi]<=1.e-14)) {
   ui=ui[!zi,,drop=F];
   ci=ci[!zi];
   nm_i=nm_i[!zi];
} else {
   cat("The following constant inequalities are not satisfied:\\n", file=stderr());
   cat(nm_i[zi][ci[zi]>1.e-14], sep="\\n", file=stderr());
   stop("see above.");
}

# complete ui by zero columns corresponding to scale params
ui=cbind(ui, matrix(0., NROW(ui), nb_param-nb_ff));
if (nb_param>nb_ff) {
   # complete ui by scales >=0
   ui=rbind(ui, cbind(matrix(0, nb_param-nb_ff, nb_ff), diag(1, nb_param-nb_ff)));
   ci=c(ci,rep(0., nb_param-nb_ff));
   nm_i=c(nm_i, paste(nm_par[(nb_ff+1):nb_param], ">=0", sep=""));
   dimnames(ui)[[1]]=nm_i;
   names(ci)=nm_i;
}

# remove redundant inequalities
nb_i=nrow(ui);
ired=c();
if (nb_i > 0) {
   for (i in 1:(nb_i-1)) {
      nmref=nm_i[i];
      for (j in setdiff((i+1):nb_i, ired)) {
         if (all(ui[j,]==ui[i,]) && ci[i]==ci[j]) {
            # redundancy
            cat("inequality ", nm_i[j], " redundant with ", nmref, " is removed.\n", sep="");
            ired=c(ired, j);
         }
      }
   }
}
if (!is.null(ired)) {
   # remove all ired inequalities
   ui=ui[-ired,,drop=F];
   ci=ci[-ired];
   nm_i=nm_i[-ired];
}
""");

def netan2j_rhs_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, incu2i_b1, fortfun="fj_rhs"):
    """
    netan2j_rhs_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, fortfun="fj_rhs")->None
    minput - input metabolites
    Write a Fortran subroutine calculating term by term j_rhs in the
    the Jacobian dx_df (or x_f) derived from cumomer balances
    for a given weight iw (input Fortran parameter)
    Flux vector fl is known from Fortran parameter list
    """
    # 2009-07-24 sokol
    
    f.write("""
C************************************************************************
C Define subroutine for jacobian rhs calculation for a given weight iw
C NB: This is an automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright 2009, INRA, France.
C
C************************************************************************


      SUBROUTINE %(fortfun)s(fl, nf, x, xw, x_f, nx, nxw, iw, j_rhs, b_x)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C For a given weight iw, update term by term j_rhs matrix
C for cumomer vector x and x_f of previous weights.
C The term b_x*x_f is not included in j_rhs, only b_x
C is calculated and returned. It is left to the care of the user
C to integrate this term to j_rhs
C
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): composite array of input and lighter cumomers
C x_f (double): matrix (nx, nf) with weight lighter than current iw
C nx (int): x  and x_f column dimension
C nxw (int): cumomer number for current weight iw
C iw (int): weight for which the matrix should be calculated
C j_rhs (double): array(nxw x nf) initial value of right hand side
C   matrix.
C Output:
C j_rhs (double): array(n x nf)
C b_x (double): array(nxw x nx)
      INTEGER            nf
      INTEGER            nx
      INTEGER            nxw
      INTEGER            iw
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(nx)
      DOUBLE PRECISION   xw(nxw)
      DOUBLE PRECISION   x_f(nx,nf)
      DOUBLE PRECISION   j_rhs(nxw,nf)
      DOUBLE PRECISION   b_x(nxw,nx)
      
C      write(0,*) "%(fortfun)s: start", nf, nx, nxw, iw,
C fluxes: %(fl)s
C composite x: %(x)s
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    "fortfun": fortfun,
    "fl": str(sorted((i,f) for (f,i) in fwrv2i.iteritems())),
    "x": str(sorted((i,c) for (c,i) in incu2i_b1.iteritems())),
    });
    for (iwl,A) in enumerate(Al):
        b=bl[iwl];
        w=iwl+1;
        cumos=vcumol[iwl];
        # current weight cumomer numbering for xw vector
        wcumo2i=dict((c,i+1) for (i,c) in enumerate(cumos));
        #print ("wcumo2i", wcumo2i);
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise Exception("Wrong cumomer number");
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        dA_dv * cumos definition
C        xw: %(cumos)s
"""%    {
        "iw": w,
        "cumos": join(", ", ((i+1,c) for (i,c) in enumerate(cumos))),
        });
        # run through the matrix A
        for irow in xrange(ncumo):
            # for a given row and vi, A_vi*x is just a sum of x concerned by vi
            # in this row.
            # This sum is added to j_rhs[irow, vi]
            visum={};
            f.write("""
C        ir=%d, cumo=%s\n"""%(irow+1, cumos[irow]));
            xsum="";
            for cumo in A[cumos[irow]].keys():
                icol=wcumo2i[cumo]-1; # back to zero based
                sign="+" if (irow != icol) else "-";
                for fl in A[cumos[irow]][cumo]:
                    visum[fl]=visum.get(fl, {"+": [], "-": []});
                    visum[fl][sign].append(cumos[icol]);
            # update irow in j_rhs with -a_v_x
            for fl in visum:
                for sign in visum[fl]:
                    term=join('+', trd(visum[fl][sign], wcumo2i, 'xw(', ')', None));
                    if not term:
                        continue;
                    code="         j_rhs(%(ir)d,%(ic)d)=j_rhs(%(ir)d,%(ic)d)%(sign)s(%(term)s)\n" % {
                        "ir": irow+1,
                        "ic": fwrv2i[fl],
                        "sign": sign,
                        "term": term,
                        };
                    f.write(fwrap(code));
            # b_v: run through the b
            if cumos[irow] not in b:
                continue;
            f.write("""
C        b_v term""");
            brow=b[cumos[irow]];
            for (fl, dlst) in brow.iteritems():
                f.write(fwrap("""
         j_rhs(%(ir)d,%(ic)d)=j_rhs(%(ir)d,%(ic)d)+%(b_v)s
""" %           {
                    "ir": irow+1,
                    "ic": fwrv2i[fl],
                    "b_v": joint("+", [
                        join("*", trd(lst, incu2i_b1, "x(", ")"))
                        for (imetab,lst) in dlst.iteritems()
        ])}));
            if iwl > 0:
                f.write("""
C        b_x term""");
            for (fl, dlst) in brow.iteritems():
                ifl=fwrv2i[fl];
                b_x="fl(%d)"%ifl;
                csum=dict();
                for (imetab,lst) in dlst.iteritems():
                    if len(lst)==1:
                        # input cumomer, skip
                        continue;
                    # derive the cumo products item*factor
                    for (item,ifct) in ((0,1), (1,0)):
                        if lst[item] in cumo2i:
                            # the item is a variable cumomer (not input) so it's derivable
                            factor=("x(%d)"%incu2i_b1[lst[ifct]]);
                            ici=cumo2i[lst[item]]; # index of cumomer item
                            if ici in csum:
                                csum[ici].append(factor);
                            else:
                                csum[ici]=[factor];
                if not csum:
                    continue;
                for (ix,factor) in csum.iteritems():
                    f.write(fwrap("""
         b_x(%(ir)d,%(ic)d)=b_x(%(ir)d,%(ic)d)+%(b_x)s*(%(factor)s)
""" %   {
        "ir": irow+1,
        "ic": ix,
        "b_x": b_x,
        "factor": join("+", factor)}));
        f.write("""
      endif
"""); # end of fortran if on iw
    f.write("""
      RETURN
      END SUBROUTINE %(fortfun)s
"""%{"fortfun": fortfun});
