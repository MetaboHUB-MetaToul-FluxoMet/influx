#!/usr/bin/env python
# Module for translation of .ftbl file to R or Fortran code

# 2009-09-14 sokol@insa-toulouse.fr : flux.[net|xch] -> [dfc].[nx].flux
#                                     flux.[fwd|rev] -> [fwd|rev].flux
# 2008-12-08 sokol@insa-toulouse.fr : added netan2Rinit()
# 2008-11-25 sokol@insa-toulouse.fr : adapted for reduced cumomer list
# 2008-09-19 sokol@insa-toulouse.fr : initial release
# Copyright 2008 INSA/INRA UMR792, MetaSys
import time;
from tools_ssg import *;
import C13_ftbl;
import copy;
import os;
import sys;
import platform;
from operator import itemgetter;

global DEBUG;
dirx=os.path.dirname(sys.argv[0]);

def fwrap(text, comment=False):
    """Wraps the text in fortran style, i.e. last char at colomn 72 and
    the following lines are prepended with "     &" (five spaces and ampresand)
    If parameter comment is True then the wrapped text is prepended
    with "C ".
    """
    lent=len(text);
    if comment:
        return "\nC ".join(text[i:min(i+72,lent)] for i in xrange(0, lent, 72));
    else:
        return text[0:72]+("\n     &" if lent > 72 else "")+"\n     &".join(text[i:min(i+66,lent)] for i in xrange(72, lent, 66));

def netan2Abcumo_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, fortfun="fwrv2Abcumo"):
    """
    Transform cumomer linear sytems collection (from ftbl file)
    to a Fortran subroutine code calculating matrix A and vector b
    in A*x=b for a given weight iw (input Fortran parameter)
    Flux vector fl of all fwd. and rev. fluxes is known from
    Fortran parameter list

    2008-08-26 sokol
    """
    f.write("""
C************************************************************************
C Define subroutine for cumomer matrix A for a given weight iw
C NB: This is an automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.
C
C************************************************************************


      SUBROUTINE %(fortfun)s(fl, nf, x, nx, iw, n, A, b, calcA, calcb)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C Calculate dense matrix for system of linear equations A*x=b
C for cumomer vector x of a given weight iw.
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): array of lighter cumomer
C nx (int): x dimension
C iw (int): weight for which the matrix should be calculated
C n (int): A dimension (n x n)
C Output:
C A (double): array(n,n) representing the system matrix.
C b (double): array(n) representing the system rhs.
      INTEGER            nf
      INTEGER            nx
      INTEGER            iw
      INTEGER            n
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(nx)
      DOUBLE PRECISION   A(n,n)
      DOUBLE PRECISION   b(n)
      LOGICAL            calcA
      LOGICAL            calcb
      
C      write(0,*) "%(fortfun)s: start", nf, nx, iw, n
%(fluxe_names)s
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    "fortfun": fortfun,
    "fluxe_names": fwrap("C fluxes: "+join(", ",
     (str(i)+"="+f for (f,i) in sorted(fwrv2i.iteritems(), key=itemgetter(1)))),
     comment=True)
    });
    for (iwl,A) in enumerate(Al):
        w=iwl+1;
        cumos=vcumol[iwl];
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        matrix definition
C        cumos: %(cumos)s
         if (calcA) then
"""%    {
        "iw": w,
        "cumos": join(", ", [(i+1,c) for (i,c) in enumerate(cumos)]),
        });
        # run through the matrix
        for icol in xrange(ncumo):
            f.write("C           (%d,%d) cumo=%s\n" % (icol+1, icol+1, cumos[icol]));
            for irow in xrange(ncumo):
                sign="-" if (irow != icol) else "";
                fli=A[cumos[irow]].get(cumos[icol],[]);
                #if set(fli)-set(fwrv2i.keys()):
                #    raise Exception("A 1ir,1ic=%d,%d: fluxes %s are not in fwrv2i."%
                #        irow+1, icol+1, set(fli)-set(fwrv2i.keys()));
                term=join('+', trd(fli, fwrv2i, 'fl(', ')', None));
                if (not term):
                    continue;
                code="            A(%(ir)d,%(ic)d)=%(sign)s(%(term)s)\n" % {
                "ir": irow+1,
                "ic": icol+1,
                "sign": sign,
                "term": term,
                };
                f.write(fwrap(code));
        # run through the rhs
        f.write("""
         endif
C        right hand side definition
         if (calcb) then
%(b)s
         endif
      endif
""" %   {
        "b": (
        join("\n", (
        fwrap("            b("+str(i+1)+")="+join("+", (
        ("fl("+str(fwrv2i[flux])+")*("
            if cumo.split(':')[0] not in minput else '') +
        joint("+", [
        join("*", trd(lst, cumo2i, "x(", ")", None))
        for (imetab,lst) in dlst.iteritems()
        ])+(")" if cumo.split(":")[0] not in minput else "")
        for (flux,dlst) in bl[iwl].get(cumo,{}).iteritems()
        ), a="0."))
        for (i,cumo) in enumerate(cumos)
        )
        )
        )
        });
    f.write("""
      RETURN
      END SUBROUTINE %(fortfun)s
"""%{"fortfun": fortfun});
def netan2Rinit(netan, org, f, ff):
    global DEBUG;
    """netan2Rinit(netan, org, f, ff)
    Write R code for initialization of all variables before
    cumomer system resolution by khi2 minimization.
    netan is a collection of parsed ftbl information
    f is R code output pointer
    ff is fortran code output pointer
    Return a dictionnary with some python variables:
        "measures": measures,
        "o_mcumos": o_mcumos,
        "cumo2i": cumo2i,
        ...
    """
    # Important python variables:
    # Collections:
    #    netan - (dict) ftbl structured content;
    #    tfallnx - (3-tuple[reac,["d"|"f"|"c"], ["n"|"x"]] list)- total flux
    #    collection;
    #    measures - (dict) exp data;
    #    rAb - (list) reduced linear systems A*x_cumo=b by weight;
    #    scale - unique scale names;
    #    nrow - counts scale names;
    #    o_sc - ordered scale names;
    #    o_meas - ordered measure types;
    # org - (str) prefix of .ftbl  file like "PPP"
    # File names (str):
    #    n_ftbl (descriptor f_ftbl);
    #    n_opt (R code) (f);
    #    n_fort (fortran code) (ff);
    # Counts: nb_fln, nb_flx, nb_fl (dependent fluxes: net, xch, total),
    #         nb_ffn, nb_ffx (free fluxes)
    # Index translators:
    #    fwrv2i - flux names to index in fwrv 1-based;
    #    cumo2i - cumomer names to index in R:x;
    #    ir2isc - mapping measure rows indexes on scale index isc[meas]=ir2isc[meas][ir]
    # Vector names:
    #    cumos (list) - names of R:x;
    #    o_mcumos - cumomers involved in measures;

    # Important R variables:
    # Scalars:
    #    nb_w, nb_cumos, nb_fln, nb_flx, nb_fl (dependent or unknown fluxes),
    #    nb_ffn, nb_ffx, nb_ff (free fluxes),
    #    nb_fcn, nb_fcx, nb_fc (constrained fluxes),
    #    nb_ineq, nb_param, nb_fmn
    # Name vectors:
    #    nm_cumo, nm_fwrv, nm_fallnx, nm_fln, nm_flx, nm_fl, nm_par,
    #    nm_ffn, nm_ffx,
    #    nm_fcn, nm_fcx,
    #    nm_mcumo, nm_fmn
    # Numeric vectors:
    #    fwrv - all fluxes (fwd+rev);
    #    x - all cumomers (weight1+weight2+...);
    #    param - free flux net, free flux xch, scale label, scale mass, scale peak
    #    fcn, fcx, fc,
    #    bp - helps to construct the rhs of flux system
    #    fallnx - complete flux vector (dep, free, constr:net+xch)
    #    bc - helps to construct fallnx
    #    li - inequality vector (mi%*%fallnx>=li)
    #    ir2isc - measur row to scale vector replicator
    #    ci - inequalities for param use (ui%*%param-ci>=0)
    #    measvec,
    #    measinvvar,
    #    imeas,
    #    fmn
    # Matrices:
    #    Afl, qrAfl, invAfl,
    #    p2bfl - helps to construct the rhs of flux system from free fluxes
    #    c2bfl - helps to construct the rhs of flux system from constr. fluxes
    #    mf, md, mc - help to construct fallnx
    #    mi - inequality matrix (ftbl content)
    #    ui - inequality matrix (ready for param use)
    #    measmat - measmat*(x[imeas];1)=vec of simulated not-yet-scaled measures
    # Functions:
    #    param2fl_x - translate param to flux and cumomer vector (initial approximation)
    #    cumo_cost - cost function (khi2)
    #    cumo_grad - finite difference gradient
    #    fallnx2fwrv - produce fw-rv fluxes from fallnx

    # Main steps:
    #    python var init;
    #    R init;
    #    R function fallnx2fwrv();
    #    python measures, cumos, cumo2i;
    #    fortran code for cumomer systems A*x=b;
    #    R var init;
    #    R Afl, qr(Afl), invAfl;
    #    R param (without scale factors);
    #    R constrained fluxes
    #    R p2bfl, c2bfl, bp
    #    R mf, md, mc
    #    R mi, li
    #    python measure matrix, vector and vars
    #    R ui, ci
    #    R measure matrix, vector, vars
    #    R flux measures

    # header
    f.write("# This is an automatically generated R code. Don't edit.\n");
    f.write("# Generated by \n# "+join(" ", sys.argv)+"\n# at "+time.ctime()+".\n");
    f.write("""
# Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.
""");
    #if DEBUG:
    #    pdb.set_trace();
    res={};
    netan2R_fl(netan, org, f, ff);
    d=netan2R_rcumo(netan, org, f, ff);
    res.update(d);
    d=netan2R_cumo(netan, org, f, ff);
    res.update(d);
    d=netan2R_meas(netan, org, f, ff);
    res.update(d);
    netan2R_ineq(netan, org, f, ff);
    return res;

def netan2R_fl(netan, org, f, ff):
    """netan2R_fl(netan, org, f, ff)
    generate R code for flux part
    for more details cf. netan2Rinit()
    """
    # dependent flux counts
    nb_fln=len(netan['vflux']['net']);
    nb_flx=len(netan['vflux']['xch']);
    nb_fl=nb_fln+nb_flx;

    # prepare index translator for free fluxes
    # it will be used in bfl expressions where names like flx.net must
    # be mapped on respecting parameter index
    nb_ffn=len(netan['flux_free']['net']);
    nb_ffx=len(netan['flux_free']['xch']);
    nb_fcn=len(netan['flux_constr']['net']);
    nb_fcx=len(netan['flux_constr']['xch']);
    ffn2iprm=dict(("f.n."+f,(i+1))
        for (f,i) in netan['vflux_free']['net2i'].iteritems());
    ffx2iprm=dict(("f.x."+f,(i+1+nb_ffn))
        for (f,i) in netan['vflux_free']['xch2i'].iteritems());

    # prepare fwrv2i
    fwrv2i=dict((f,i+1) for (f,i) in netan["vflux_fwrv"]["fwrv2i"].iteritems());
    nb_fwrv=len(netan["vflux_fwrv"]["fwrv2i"]);

    # make tuple for complete flux vector d,f,c
    # (name,"d|f|c","net|xch")
    tfallnx=zip(
            netan["vflux"]["net"]+
            netan["vflux_free"]["net"]+
            netan["vflux_constr"]["net"]+
            netan["vflux"]["xch"]+
            netan["vflux_free"]["xch"]+
            netan["vflux_constr"]["xch"],

            ["d"]*len(netan["vflux"]["net"])+
            ["f"]*len(netan["vflux_free"]["net"])+
            ["c"]*len(netan["vflux_constr"]["net"])+
            ["d"]*len(netan["vflux"]["xch"])+
            ["f"]*len(netan["vflux_free"]["xch"])+
            ["c"]*len(netan["vflux_constr"]["xch"]),

            ["n"]*len(netan["vflux"]["net"])+
            ["n"]*len(netan["vflux_free"]["net"])+
            ["n"]*len(netan["vflux_constr"]["net"])+
            ["x"]*len(netan["vflux"]["xch"])+
            ["x"]*len(netan["vflux_free"]["xch"])+
            ["x"]*len(netan["vflux_constr"]["xch"]),
            );

    f.write("""
# get runtime arguments if not already set
# opts=strsplit("--sens mc=5", " ")[[1]];
if (length(find("opts"))==0) {
   opts=commandArgs();
}
# profile or not profile?
prof=(length(which(opts=="--prof")) > 0);

# is there a method for sensitivity matrix calculation?
sensitive=which(opts=="--sens");
if (length(sensitive)) {
   sensitive=opts[sensitive[1]+1];
} else {
   sensitive=""; # no sensitivity matrix calculation
}
if (is.na(sensitive)) {
   sensitive=""; # no sensitivity matrix calculation
}
if (substring(sensitive, 1, 3)=="mc=") {
   # read the mc iteration number
   nmc=as.integer(substring(sensitive, 4));
   sensitive="mc";
} else if (sensitive=="mc") {
   nmc=10;
}
#cat("sens=", sensitive, "\\n");
optimize=TRUE;
argopt=which(opts=="--noopt");
if (length(argopt)) {
   optimize=FALSE;
}
# R profiling
if (prof) {
   Rprof("%(proffile)s");
}

# minimization method
validmethods=list("BFGS", "Nelder-Mead", "SANN", "nlsic");
method=which(opts=="--meth");
if (length(method)) {
   method=opts[method[1]+1];
   if (! method %%in%% validmethods) {
      warning(paste("method", method, "is not known."));
      method="nlsic";
   }
} else {
   method="nlsic";
}

# get some tools
source("%(dirx)s%(psep)stools_ssg.R");
source("%(dirx)s%(psep)sopt_cumo_tools.R");
#require(matrid, lib.loc="/home/sokol/R/lib");
dyn.load("%(sofile)s");

# custom functions
# produce fw-rv fluxes from fallnx
fallnx2fwrv=function(fallnx) {
   n=length(fallnx);
   # extract and reorder in fwrv order
   net=fallnx[c(%(inet2ifwrv)s)];
   xch=fallnx[c(%(ixch2ifwrv)s)];
   # expansion 0;1 -> 0;+inf of xch (second half of fallnx)
   xch=xch/(1-xch);
   # fw=xch-min(-net,0)
   # rv=xch-min(net,0)
   fwrv=c(xch-pmin(-net,0),xch-pmin(net,0));
   if (DEBUG) {
      n=length(fwrv);
      library(MASS);
      names(fwrv)=nm_fwrv
      write.matrix(fwrv, file="dbg_fwrv.txt", sep="\\t");
   }
   return(fwrv);
}
""" % {
        "inet2ifwrv": join(", ", (1+
        (netan["vflux"]["net2i"][fl[4:]] if fl[4:] in netan["vflux"]["net2i"]
        else nb_fln+netan["vflux_free"]["net2i"][fl[4:]] if fl[4:] in netan["vflux_free"]["net2i"]
        else nb_fln+nb_ffn+netan["vflux_constr"]["net2i"][fl[4:]])
        for fl in netan["vflux_fwrv"]["fwrv"][:nb_fwrv/2])),
        "ixch2ifwrv": join(", ", (1+len(netan["vflux_fwrv"]["fwrv"])/2+
        (netan["vflux"]["xch2i"][fl[4:]] if fl[4:] in netan["vflux"]["xch2i"]
        else nb_flx+netan["vflux_free"]["xch2i"][fl[4:]] if fl[4:] in netan["vflux_free"]["xch2i"]
        else nb_flx+nb_ffx+netan["vflux_constr"]["xch2i"][fl[4:]])
        for fl in netan["vflux_fwrv"]["fwrv"][:nb_fwrv/2])),
        "proffile": escape(os.path.basename(f.name)[:-1]+"Rprof", "\\"),
        "sofile": escape(os.path.basename(ff.name)[:-1]+
            ("dll" if platform.system() == "windows" else "so"), "\\"),
        "dirx": escape(dirx, "\\"),
        "psep": escape(os.sep, "\\"),
    });
    f.write("""
# fwd-rev flux names
nm_fwrv=c(%(nm_fwrv)s);

# net-xch flux names
nm_fallnx=c(%(nm_fallnx)s);

# initialize the linear system Afl*flnx=bfl (0-weight cumomers)
# unknown net flux names
nm_fln=c(%(nm_fln)s);
nb_fln=length(nm_fln);
# unknown xch flux names
nm_flx=c(%(nm_flx)s);
nb_flx=length(nm_flx);
nm_fl=c(nm_fln, nm_flx);
nb_fl=nb_fln+nb_flx;
# flux matrix
if (nb_fl) {
   Afl=matrix(c(%(Afl)s), ncol=nb_fl, byrow=TRUE);
} else {
   Afl=matrix(0., nb_fl, nb_fl);
}
dimnames(Afl)=list(c(%(nm_rows)s), nm_fl);
if (DEBUG) {
   library(MASS);
   write.matrix(Afl, file="dbg_Afl.txt", sep="\\t");
}
if (nrow(Afl) != ncol(Afl)) {
   write.table(Afl);
   stop(paste("Flux matrix is not square: (", nrow(Afl), "eq x ", ncol(Afl), "unk)\\n",
   "You have to change your choice of free fluxes in the '%(n_ftbl)s' file", sep=""));
}

qrAfl=qr(Afl);

# make sure that free params choice leads to not singular matrix
if (qrAfl$rank != nb_fl) {
   write.table(Afl);
   stop("Flux matrix is singular. You have to change your choice of free fluxes in the '%(n_ftbl)s' file");
}

# inverse flux matrix
invAfl=solve(qrAfl);

# prepare param (\Theta) vector
# order: free flux net, free flux xch, scale label, scale mass, scale peak
param=numeric(0);
nm_par=c();
# free net fluxes
nb_ffn=%(nb_ffn)d;
nm_ffn=c(%(nm_ffn)s);
# starting values for iterations
param=c(param, c(%(ffn)s));
if (nb_ffn) {
   nm_par=c(nm_par, nm_ffn);
}
# free xch fluxes
nb_ffx=%(nb_ffx)d;
nm_ffx=c(%(nm_ffx)s);
# starting values for iterations
param=c(param, c(%(ffx)s));
if (nb_ffx) {
   nm_par=c(nm_par, nm_ffx);
}
nb_param=length(param);
# scaling factors are added to param later

nb_ff=nb_ffn+nb_ffx;
# constrained fluxes
# net
nb_fcn=%(nb_fcn)d;
nm_fcn=c(%(nm_fcn)s);
fcn=c(%(fcn)s);
# xch
nb_fcx=%(nb_fcx)d;
nm_fcx=c(%(nm_fcx)s);
fcx=c(%(fcx)s);
fc=c(fcn, fcx);
nm_fc=c(nm_fcn, nm_fcx)
names(fc)=nm_fc;
nb_fc=nb_fcn+nb_fcx;

# total flux vector fallnx dimension
nb_fallnx=nb_fl+nb_ff+nb_fc;

# all flux cardinals
nb_f=list(nb_fln=nb_fln, nb_flx=nb_flx, nb_fl=nb_fl,
   nb_ffn=nb_ffn, nb_ffx=nb_ffx, nb_ff=nb_ff,
   nb_fcn=nb_fcn, nb_fcx=nb_fcx, nb_fc=nb_fc,
   nb_fallnx=nb_fallnx);

""" % {
    "n_ftbl": escape(org+".ftbl", "\\"),
    "nm_fwrv": join(", ", netan["vflux_fwrv"]["fwrv"], '"', '"'),
    "nm_fallnx": join(", ", (join(".", (t[1],t[2],t[0])) for t in tfallnx), '"', '"'),
    "nm_fln": join(", ", netan["vflux"]["net"], '"d.n.', '"'),
    "nm_flx": join(", ", netan["vflux"]["xch"], '"d.x.', '"'),
    "Afl": join(", ", [coef for coef in valval(netan['Afl'])]),
    "nm_rows": join(", ", netan["vrowAfl"], '"', '"'),
    "nb_ffn": nb_ffn,
    "nb_ffx": nb_ffx,
    "nm_ffn": join(", ", netan["vflux_free"]["net"], '"f.n.', '"'),
    "nm_ffx": join(", ", netan["vflux_free"]["xch"], '"f.x.', '"'),
    "ffn": join(", ", [netan["flux_free"]["net"][fl]
        for fl in netan["vflux_free"]["net"]]),
    "ffx": join(", ", [netan["flux_free"]["xch"][fl]
        for fl in netan["vflux_free"]["xch"]]),
    "nb_fcn": len(netan["flux_constr"]["net"]),
    "nb_fcx": len(netan["flux_constr"]["xch"]),
    "nm_fcn": join(", ", netan["vflux_constr"]["net"], '"c.n.', '"'),
    "nm_fcx": join(", ", netan["vflux_constr"]["xch"], '"c.x.', '"'),
    "fcn": join(", ", [netan["flux_constr"]["net"][fl]
        for fl in netan["vflux_constr"]["net"]]),
    "fcx": join(", ", [netan["flux_constr"]["xch"][fl]
        for fl in netan["vflux_constr"]["xch"]]),
    });
    f.write("""
# prepare p2bfl, c2bfl, cnst2bfl matrices such that p2bfl%*%param[1:nb_ff]+
# c2bfl%*%fc+cnst2bfl=bfl
# replace f.[nx].flx by corresponding param coefficient
p2bfl=matrix(0., 0, nb_ff);
# replace c.[nx].flx by corresponding fc coefficient
c2bfl=matrix(0., 0, nb_fc);
cnst2bfl=numeric(0); # can come from equalities
colnames(p2bfl)=nm_par;
colnames(c2bfl)=nm_fc;
""");
    for item in netan["bfl"]:
        f.write("\
p2bfl=rbind(p2bfl, c(%(row)s));\n\
c2bfl=rbind(c2bfl, c(%(rowc)s));\n\
cnst2bfl=c(cnst2bfl, c(%(rowcnst)s));\n\
"%{
        "row": join(", ",
        (item.get("f."+suf+"."+fl, "0.") for (suf, fl) in
        zip(["n"]*nb_ffn+["x"]*nb_ffx,
        netan['vflux_free']['net']+netan['vflux_free']['xch']))),
        "rowc": join(", ",
        (item.get("c."+suf+"."+fl, "0.") for (suf, fl) in
        zip(["n"]*nb_fcn+["x"]*nb_fcx,
        netan['vflux_constr']['net']+netan['vflux_constr']['xch']))),
        "rowcnst": item.get("", 0.),
        });
    f.write("""
bp=c2bfl%*%fc+cnst2bfl;

# intermediate jacobian
dfl_dff = invAfl %*% p2bfl

# prepare mf, md matrices and bd vector
# such that mf%*%ff+md%*%fl+mc%*%fc gives fallnx
# here ff free fluxes (param), fl are dependent fluxes and fc are constrained
# fluxes
mf=matrix(0.,0,nb_ff);
md=matrix(0.,0,nb_fl);
mc=matrix(0.,0,nb_fc);
bc=numeric(0);
""");

    for tf in tfallnx:
        f.write("""
mf=rbind(mf,c(%(mf)s));
md=rbind(md,c(%(md)s));
mc=rbind(mc,c(%(mc)s));
"""%{
    "mf": join(", ", (1 if tf==(fl,t,nx) else 0 for (fl,t,nx) in tfallnx if t=="f")),
    "md": join(", ", (1 if tf==(fl,t,nx) else 0 for (fl,t,nx) in tfallnx if t=="d")),
    "mc": join(", ", (1 if tf==(fl,t,nx) else 0 for (fl,t,nx) in tfallnx if t=="c")),
    });
    netan["fwrv2i"]=fwrv2i;
    netan["tfallnx"]=tfallnx;

def netan2R_meas(netan, org, f, ff):
    """netan2R_meas(netan, org, f, ff)
    generate code for measure treatment
    """
    # prepare python measures
    if "measures" not in netan:
        print("Calculate measures in netan2R_meas.");
        measures=dict();
        for meas in ("label", "mass", "peak"):
            measures[meas]=eval("C13_ftbl.%s_meas2matrix_vec_dev(netan)"%meas);
        netan["measures"]=measures;
    measures=netan["measures"];
    #aff("got measures in netan2R_meas", measures);##
    # get scaling factors and their indexes, measure matrices, and measured cumomer value vector
    scale={"label": {}, "mass": {}, "peak": {}}; # for unique scale names
    nrow={"label": {}, "mass": {}, "peak": {}}; # for counting scale names
    o_sc={"label": {}, "mass": {}, "peak": {}}; # for ordered unique scale names
    o_meas=measures.keys(); # ordered measure types
    o_meas.sort();

    if DEBUG:
        pdb.set_trace();

    ir2isc={"label": [], "mass": [], "peak": []}; # for mapping measure rows indexes on scale index
    # we want to use it in python like isc[meas]=ir2isc[meas][ir]
    for meas in o_meas:
        # get unique scaling factors
        # and count rows in each group
        # row["scale"] is "metab;group" (metab name may be fake here)
        for (i,row) in enumerate(measures[meas]["mat"]):
            scale[meas][row["scale"]]=0.;
            nrow[meas][row["scale"]]=nrow[meas].get(row["scale"],0.)+1;
        # remove groups having only one measure in them
        for (k,n) in list(nrow[meas].iteritems()):
            if n<2:
                del(scale[meas][k]);
        # order scaling factor
        o_sc[meas]=scale[meas].keys();
        o_sc[meas].sort();
        # map a measure rows (card:n) on corresponding scaling factor (card:1)
        # if a row has not scale factor it is scaled with factor 1
        # vector having scaling parameters is formed like
        # c(1,param);
        ir2isc[meas]=[-1]*len(measures[meas]["mat"]);
        for (i,row) in enumerate(measures[meas]["mat"]):
            if row["scale"] in scale[meas]:
                ir2isc[meas][i]=o_sc[meas].index(row["scale"]);

        # measured value vector is in measures[meas]["vec"]
        # measured dev vector is in measures[meas]["dev"]

    if DEBUG:
        pdb.set_trace();

    # create R equivalent structures with indices for scaling
    f.write("\n# make place for scaling factors\n");
    for meas in o_meas:
        if not o_sc[meas]:
            continue;
        f.write("""
# %(meas)s
# initial values for scales are set later
param=c(param,%(sc)s);
nm_par=c(nm_par,c(%(sc_names)s));
""" % {
        "meas": meas,
        "sc": join(", ", (scale[meas][sc] for sc in o_sc[meas])),
        "sc_names": join(", ", o_sc[meas], '"'+meas+';', '"'),
        });

    f.write("""
nb_param=length(param);
nb_sc=nb_param-nb_ff;
# indices mapping from scaling to measure matrix row
# c(1,par)[ir2isc] replicates scale parameters
# for corresponding rows of measure matrix
ir2isc=numeric(0);
""");
    base_isc=1;
    for meas in o_meas:
        f.write("""
# %(meas)s
ir2isc=c(ir2isc,c(%(ir2isc)s));
""" % {
        "nsc_meas": len(scale[meas]),
        "meas": meas,
        "sc_names": join(", ", o_sc[meas], '"', '"'),
        "ir2isc": join(", ", ((str(ir2isc[meas][ir]+base_isc) if ir2isc[meas][ir]>=0 else -1)
            for ir in xrange(len(ir2isc[meas]))))
        });
        base_isc=base_isc+len(scale[meas]);

    f.write("""
# shift indices by nb_ff+1
ir2isc[ir2isc>0]=ir2isc[ir2isc>0]+nb_ff+1;
ir2isc[ir2isc<=0]=1;
""");
    # get the full dict of non zero cumomers involved in measures
    # cumo=metab:icumo where icumo is in [1;2^Clen]
    if DEBUG:
        pdb.set_trace();
    meas_cumos={};
    for meas in o_meas:
        for row in measures[meas]["mat"]:
            metab=row["metab"];
            meas_cumos.update((metab+":"+str(icumo), "") for icumo in row["coefs"].keys() if icumo != 0);

    # order involved cumomers
    o_mcumos=meas_cumos.keys();
    o_mcumos.sort();
    imcumo2i=dict((cumo, i) for (i, cumo) in enumerate(o_mcumos));
    nb_mcumo=len(o_mcumos);
    f.write("""
# make measure matrix
# matrix is "densified" such that
# measmat*(x[imeas];1) or measmat*(xr[irmeas];1)vec of simulated not-yet-scaled measures
# where imeas is the R-index of involved in measures cumomers
# all but 0. Coefficients of 0-cumomers, by defenition equal to 1,
# are all regrouped in the last matrix column.
measmat=matrix(0., 0, %(ncol)d);
measvec=numeric(0);
measinvvar=numeric(0);
nm_meas=c();
imeas=c(%(imeas)s);
irmeas=c(%(irmeas)s);
nm_mcumo=c(%(mcumos)s);
"""%{
    "nrow": len([measures[meas]["vec"] for meas in measures]),
    "ncol": (nb_mcumo+1),
    "imeas": join(", ", trd(o_mcumos,netan["cumo2i"],a="")),
    "irmeas": join(", ", trd(o_mcumos,netan["rcumo2i"],a="")),
    "mcumos": join(", ", o_mcumos, '"', '"'),
    });

    # get coeffs in the order above with their corresponding indices from total cumomer vector
    measmat=[];
    for meas in o_meas:
        if not measures[meas]["mat"]:
            continue;
        f.write("""
# %s
"""%meas);
        #print("meas="+meas+"; mat="+str(measures[meas]["mat"]));##
        for row in measures[meas]["mat"]:
            metab=row["metab"];
            res=[0]*(nb_mcumo+1); # initialize the row to zeros
            for (icumo,coef) in row["coefs"].iteritems():
                col=imcumo2i[metab+":"+str(icumo)] if icumo else nb_mcumo;
                res[col]=coef;
            #try:
            #except:
            #    tmp="+".join(row["bcumos"]);
            #except:
            #    print("meas="+meas, "; row="+str(row));##
            #    raise;
            f.write("""measmat=rbind(measmat,c(%(row)s));
nm_meas=c(nm_meas, "%(nm_meas)s");
"""%{"row": join(", ", res),
     "nm_meas": meas+":"+metab+":"+"+".join(row["bcumos"]),
    });
        f.write("""
measvec=c(measvec,c(%(vec)s));
measinvvar=c(measinvvar,c(%(invvar)s));
"""%{
        "vec": join(", ", measures[meas]["vec"]),
        "invvar": join(", ", (1./(dev*dev) for dev in measures[meas]["dev"])),
        });

    f.write("""
dimnames(measmat)=list(nm_meas, c(nm_mcumo, "#x*"));
# prepare flux measures
nb_fmn=%(nb_fmn)d;
nm_fmn=c(%(nm_fmn)s);

# measured values
fmn=c(%(fmn)s);

# inverse of variance for flux measures
invfmnvar=c(%(invfmnvar)s);

# indices for measured fluxes
# fallnx[ifmn]=>fmn, here fallnx is complete net|xch flux vector
# combining unknown (dependent), free and constrainded fluxes
ifmn=c(%(ifmn)s);

"""%{
    "nb_fmn": len(netan["vflux_meas"]["net"]),
    "nm_fmn": join(", ", netan["vflux_meas"]["net"], '"f.n.', '"'),
    "fmn": join(", ", (netan["flux_measured"][fl]["val"]
        for fl in netan["vflux_meas"]["net"])),
    "invfmnvar": join(", ", (1./(netan["flux_measured"][fl]["dev"]**2)
        for fl in netan["vflux_meas"]["net"])),
    "ifmn": join(", ", (1+netan["vflux_compl"]["net2i"][fl]
        for fl in netan["vflux_meas"]["net"])),
    });
    return {
        "o_meas": o_meas,
        "measures": measures,
        "o_mcumos": o_mcumos,
        "imcumo2i": imcumo2i,
    };

def netan2R_rcumo(netan, org, f, ff):
    # prepare reduced python systems
    rAb=C13_ftbl.rcumo_sys(netan);
    # full matrix is rAb=netan["cumo_sys"]

    # prune ordered cumomer list in reverse order
    # so that deleted item does not change the index
    # for the rest items to prune
    if "vrcumo" not in netan:
        netan["vrcumo"]=copy.deepcopy(netan["vcumo"]);
        for i in xrange(len(netan["vrcumo"]),len(rAb["A"]),-1):
            del(netan["vrcumo"][i-1]);
        for (iw,cumol) in enumerate(netan["vrcumo"]):
            for i in xrange(len(cumol), 0, -1):
                i-=1;
                if cumol[i] not in rAb["A"][iw]:
                    #print "prune", i, cumol[i];##
                    del(cumol[i]);
    # prepare cumo2i
    # translate cumoname like A:7 to its index in R vector of cumomers
    rcumos=list(valval(netan["vrcumo"]));
    rcumo2i=dict((c,i+1) for (i,c) in enumerate(rcumos));
    # write code for reduced cumomer systems
    netan2Abcumo_f(rAb["A"], rAb["b"],
        netan["vrcumo"], netan["input"], ff, netan["fwrv2i"], rcumo2i, "fwrv2rAbcumo");
    netan2j_rhs_f(rAb["A"], rAb["b"],
        netan["vrcumo"], netan["input"], ff, netan["fwrv2i"], rcumo2i, "frj_rhs");
    # write R constants and names
    f.write("""
# weight count
nb_rw=%(nb_rw)d;
# cumomer count by weight;
nb_rcumos=c(%(nb_rc)s);
# cumo names
nm_rcumo=c(%(nm_rcumo)s);
"""%{
    "nb_rw": len(rAb["A"]),
    "nb_rc": join(", ", (len(a) for a in rAb["A"])),
    "nm_rcumo": join(", ", valval(netan['vrcumo']), '"', '"'),
});
    netan["rcumo2i"]=rcumo2i;
    return {
        "rcumo2i": rcumo2i,
        "rAb": rAb,
    };

def netan2R_cumo(netan, org, f, ff):
    """netan2R_cumo(netan, org, f, ff)->dict
    generate fortran code for matrices
    """
    # prepare cumo2i
    # translate cumoname like A:7 to its index in R vector of cumomers
    cumos=list(valval(netan["vcumo"]));
    cumo2i=dict((c,i+1) for (i,c) in enumerate(cumos));

    # write fortran code for complete cumomer systems
    netan2Abcumo_f(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
        netan["vcumo"], netan["input"], ff, netan["fwrv2i"], cumo2i, "fwrv2Abcumo");
    # debug
    netan2j_rhs_f(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
        netan["vcumo"], netan["input"], ff, netan["fwrv2i"], cumo2i, "fj_rhs");
    # write R constants and names
    f.write("""
# weight count
nb_w=%(nb_w)d;

# cumomer count by weight;
nb_cumos=c(%(nb_c)s);

# cumo names
nm_cumo=c(%(nm_cumo)s);
"""%{
    "nb_w": len(netan["cumo_sys"]["A"]),
    "nb_c": join(", ", (len(a) for a in netan["cumo_sys"]["A"])),
    "nm_cumo": join(", ", valval(netan['vcumo']), '"', '"'),
});
    netan["cumo2i"]=cumo2i;
    return {
        "cumo2i": cumo2i,
    };

def netan2R_ineq(netan, org, f, ff):
    """netan2R_ineq(netan, org, f, ff)
    generate inequality code
    """
    # ex: netan["flux_inequal"]
    # {'net': [], 'xch': [('0.85', '>=', {'v2': '+1.'})]}
    tfallnx=netan["tfallnx"];
    #dict2kvh(dict((i,t) for (i,t) in enumerate(tfallnx)), "tfallnx.kvh");##
    f.write("""
# prepare mi matrix and li vector
# such that mi%*%fallnx>=li corresponds
# to the inequalities given in ftbl file
mi=matrix(0.,0,nb_fallnx);
li=numeric(0);
nm_i=c();
""");
    
    for (ineq,inx) in zip(
            netan["flux_inequal"]["net"]+
            netan["flux_inequal"]["xch"],
            ["n"]*len(netan["flux_inequal"]["net"])+
            ["x"]*len(netan["flux_inequal"]["xch"])
            ):
        f.write("""
mi=rbind(mi,c(%(mi)s));
li=c(li,%(li)g);
nm_i=c(nm_i,"%(nm)s");
"""%{
    # as R inequality is always ">=" we have to inverse the sign for "<=" in ftbl
    "mi": join(", ", (("" if ineq[1]=="<=" or ineq[1]=="=<" else "-")+
        (str(ineq[2][fl]) if inx==nx and fl in ineq[2] else "0.")
        for (fl,t,nx) in tfallnx)),
    "li": float(("" if ineq[1]=="<=" or ineq[1]=="=<" else "-")+str(ineq[0])),
    "nm": inx+":"+join("", (ineq[0], ineq[1], join("+",
        ((str(fa)+"*" if fa != 1. else "")+fl for (fl,fa) in ineq[2].iteritems())))),
    });
    f.write("""
# add standard limits on [df].xch 0;0.999
""");
    for (fli,t,nxi) in tfallnx:
        if nxi=="n" or t=="c":
            continue;
        f.write("""
mi=rbind(mi,c(%(mi0)s));
mi=rbind(mi,c(%(mi1)s));
li=c(li, 0., -0.999);
nm_i=c(nm_i, "%(nm0)s", "%(nm1)s");
"""%{
    "mi0": join(", ", (
        ("1." if fli==fl and nx=="x" else "0.") for (fl,t,nx) in tfallnx)),
    "mi1": join(", ", (
        ("-1." if fli==fl and nx=="x" else "0.") for (fl,t,nx) in tfallnx)),
    "nm0": t+"."+nxi+"."+fli+">=0",
    "nm1": t+"."+nxi+"."+fli+"<=0.999",
    });
    f.write("""
# add standard limits on net >= 1.e-5 for not reversible reactions
""");
    for (fli,t,nxi) in tfallnx:
        if nxi=="x" or fli not in netan["notrev"]:
            continue;
        f.write("""
mi=rbind(mi,c(%(mi)s));
li=c(li,1.e-5);
nm_i=c(nm_i,"%(nm)s");
"""%{
    "mi": join(", ", (
        ("1." if fli==fl and nx=="n" else "0.") for (fl,t,nx) in tfallnx)),
    "nm": t+"."+nxi+"."+fli+">=1.e-5",
    });

    f.write("nb_ineq=NROW(li);\n");
    f.write("""
dimnames(mi)=list(nm_i, nm_fallnx);
names(li)=nm_i;
# prepare ui matrix and ci vector for optimisation
# ui%*%param-ci>=0
# it is composed of explicite inequalities from ftbl
# and permanent inequalities 0<=xch<=0.999 and scale>=0

# constraints such that ui%*%param[1:nb_ff]-ci>=0
ui=mi%*%(md%*%invAfl%*%p2bfl+mf);
ci=li-mi%*%(md%*%invAfl%*%(c2bfl%*%fc+cnst2bfl) + mc%*%fc);

# remove all zero rows in ui (constrained fluxes with fixed values)
# find zero indexes
zi=apply(ui,1,function(v){r=range(v); return(max(abs(v))<=1.e-14)});
if (all(ci[zi]<=1.e-14)) {
   ui=ui[!zi,];
   ci=ci[!zi];
   nm_i=nm_i[!zi];
} else {
   cat("The following constant inequalities are not satisfied:\\n");
   cat(nm_i[zi][ci[zi]>1.e-14], sep="\\n");
   stop();
}
# complete ui by zero columns corresponding to scale params
ui=cbind(ui, matrix(0., NROW(ui), nb_param-nb_ff));

if (nb_param>nb_ff) {
   # complete ui by scales >=0
   ui=rbind(ui, cbind(matrix(0, nb_param-nb_ff, nb_ff), diag(1, nb_param-nb_ff)));
   ci=c(ci,rep(0., nb_param-nb_ff));
   nm_i=c(nm_i, paste(nm_par[(nb_ff+1):nb_param], ">=0", sep=""));
   dimnames(ui)[[1]]=nm_i;
   names(ci)=nm_i;
}
""");

def netan2j_rhs_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, fortfun="fj_rhs"):
    """
    netan2j_rhs_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, fortfun="fj_rhs")->None
    minput - input metabolites
    Write a Fortran subroutine calculating term by term j_rhs in the
    the Jacobian dx_df (or x_f) derived from cumomer balances
    for a given weight iw (input Fortran parameter)
    Flux vector fl is known from Fortran parameter list

    2009-07-24 sokol
    """
    f.write("""
C************************************************************************
C Define subroutine for jacobian rhs calculation for a given weight iw
C NB: This is an automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright 2009, INRA, France.
C
C************************************************************************


      SUBROUTINE %(fortfun)s(fl, nf, x, xw, x_f, nx, nxw, iw, j_rhs, b_x)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C For a given weight iw, update term by term j_rhs matrix
C for cumomer vector x and x_f of previous weights.
C The term b_x*x_f is not included in j_rhs, only b_x
C is calculated and returned. It is left to care of the user
C to integrate this term to j_rhs
C
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): array of cumomer with weight lighter than current iw
C x_f (double): matrix (nx, nf) with weight lighter than current iw
C nx (int): x  and x_f column dimension
C nxw (int): cumomer number for current weight iw
C iw (int): weight for which the matrix should be calculated
C j_rhs (double): array(nxw x nf) initial value of right hand side
C   matrix.
C Output:
C j_rhs (double): array(n x nf)
C b_x (double): array(nxw x nx)
      INTEGER            nf
      INTEGER            nx
      INTEGER            nxw
      INTEGER            iw
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(nx)
      DOUBLE PRECISION   xw(nxw)
      DOUBLE PRECISION   x_f(nx,nf)
      DOUBLE PRECISION   j_rhs(nxw,nf)
      DOUBLE PRECISION   b_x(nxw,nx)
      
C      write(0,*) "%(fortfun)s: start", nf, nx, nxw, iw,
C fluxes: %(fl)s
C all weight x: %(x)s
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    "fortfun": fortfun,
    "fl": str(sorted((i,f) for (f,i) in fwrv2i.iteritems())),
    "x": str(sorted((i,c) for (c,i) in cumo2i.iteritems())),
    });
    for (iwl,A) in enumerate(Al):
        b=bl[iwl];
        w=iwl+1;
        cumos=vcumol[iwl];
        # current weight cumomer numbering for xw vector
        wcumo2i=dict((c,i+1) for (i,c) in enumerate(cumos));
        #print ("wcumo2i", wcumo2i);
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise Exception("Wrong cumomer number");
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        dA_dv * cumos definition
C        xw: %(cumos)s
"""%    {
        "iw": w,
        "cumos": join(", ", ((i+1,c) for (i,c) in enumerate(cumos))),
        });
        # run through the matrix A
        for irow in xrange(ncumo):
            # for a given row and vi, A_vi*x is just a sum of x concerned by vi
            # in this row.
            # This sum is added to j_rhs[irow, vi]
            visum={};
            f.write("""
C        ir=%d, cumo=%s\n"""%(irow+1, cumos[irow]));
            xsum="";
            for cumo in A[cumos[irow]].keys():
                icol=wcumo2i[cumo]-1; # back to zero based
                sign="+" if (irow != icol) else "-";
                for fl in A[cumos[irow]][cumo]:
                    visum[fl]=visum.get(fl, {"+": [], "-": []});
                    visum[fl][sign].append(cumos[icol]);
            # update irow in j_rhs with -a_v_x
            for fl in visum:
                for sign in visum[fl]:
                    term=join('+', trd(visum[fl][sign], wcumo2i, 'xw(', ')', None));
                    if not term:
                        continue;
                    code="         j_rhs(%(ir)d,%(ic)d)=j_rhs(%(ir)d,%(ic)d)%(sign)s(%(term)s)\n" % {
                        "ir": irow+1,
                        "ic": fwrv2i[fl],
                        "sign": sign,
                        "term": term,
                        };
                    f.write(fwrap(code));
            # b_v: run through the b
            if cumos[irow] not in b:
                continue;
            f.write("""
C        b_v term""");
            brow=b[cumos[irow]];
            for (fl, dlst) in brow.iteritems():
                f.write(fwrap("""
         j_rhs(%(ir)d,%(ic)d)=j_rhs(%(ir)d,%(ic)d)+%(b_v)s
""" %           {
                    "ir": irow+1,
                    "ic": fwrv2i[fl],
                    "b_v": joint("+", [
                        join("*", trd(lst, cumo2i, "x(", ")", None))
                        for (imetab,lst) in dlst.iteritems()
        ])}));
            if iwl > 0:
                f.write("""
C        b_x term""");
            for (fl, dlst) in brow.iteritems():
                ifl=fwrv2i[fl];
                b_x="fl(%d)"%ifl;
                csum=dict();
                for (imetab,lst) in dlst.iteritems():
                    if len(lst)==1:
                        # input cumomer, skip
                        continue;
                    # derive the cumo products item*factor
                    for (item,ifct) in ((0,1), (1,0)):
                        if lst[item] in cumo2i:
                            factor=("x(%d)"%cumo2i[lst[ifct]]) if lst[ifct] in cumo2i else lst[ifct];
                            ici=cumo2i[lst[item]]; # index of cumomer item
                            if ici in csum:
                                csum[ici].append(factor);
                            else:
                                csum[ici]=[factor];
                if not csum:
                    continue;
                for (ix,factor) in csum.iteritems():
                    f.write(fwrap("""
         b_x(%(ir)d,%(ic)d)=b_x(%(ir)d,%(ic)d)+%(b_x)s*(%(factor)s)
""" %   {
        "ir": irow+1,
        "ic": ix,
        "b_x": b_x,
        "factor": join("+", factor)}));
        f.write("""
      endif
"""); # end of fortran if on iw
    f.write("""
      RETURN
      END SUBROUTINE %(fortfun)s
"""%{"fortfun": fortfun});
