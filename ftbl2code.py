#!/usr/bin/env python
# Module for translation of .ftbl file to R or Fortran code

# 2008-09-19 sokol@insa-toulouse.fr
# Copyright 2008 INSA/INRA UMR792, MetaSys
import time;
from tools_ssg import *;

def netan2Abcumo_f(netan, f, fwrv2i, cumo2i):
    """
    Transform netan collection (from ftbl file)
    to a Fortran subroutine code calculating matrix A and vector b
    in A*x=b for a given weight iw (input Fortran parameter)
    Flux vector fl is known from Fortran parameter list

    2008-08-26 sokol
    """
    f.write("""
C************************************************************************
C Define subroutine for cumomer matrix A for a given weight iw
C NB: This is automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.
C
C************************************************************************


      SUBROUTINE fwrv2Abcumo(fl, nf, x, nx, iw, n, A, b)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C Calculate dense matrix for system of linear equations A*x=b
C for cumomer vector x of a given weight iw.
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): array of lighter cumomer
C nx (int): x dimension
C iw (int): weight for which the matrix should be calculated
C n (int): A dimension (n x n)
C Output:
C A (double): array(n,n) representing the system matrix.
C b (double): array(n) representing the system rhs.
      INTEGER            nf
      INTEGER            nx
      INTEGER            iw
      INTEGER            n
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(nx)
      DOUBLE PRECISION   A(n,n)
      DOUBLE PRECISION   b(n)
      
C      write(0,*) "fwrv2Abcumo: start", nf, nx, iw, n
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    });
    for w in xrange(1,netan['Cmax']+1):
        cumos=netan['vcumo'][w-1];
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        A=netan['cumo_sys']['A'][w-1];
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        matrix definition
C        cumos: %(cumos)s
"""%    {
        "iw": w,
        "cumos": join(", ", cumos),
        });
        # run through the matrix
        for icol in xrange(ncumo):
            for irow in xrange(ncumo):
                sign="-" if (irow != icol) else "";
                term=join('+', trd(A[cumos[irow]].get(cumos[icol],[]), fwrv2i, 'fl(', ')', None));
                if (not term):
                    continue;
                f.write("         A(%(ir)d,%(ic)d)=%(sign)s(%(term)s);\n" % {
                "ir": irow+1,
                "ic": icol+1,
                "sign": sign,
                "term": term,
                });
        # run through the rhs
        f.write("""
C        right hand side definition
%(b)s
      endif
""" %   {
        "b": (
        join("\n", (
        "         b("+str(i+1)+")="+join("+", (
        ("fl("+str(fwrv2i[flux])+")*("
            if cumo.split(':')[0] not in netan['input'] else '') +
        joint("+", [
        join("*", trd(lst, cumo2i, "x(", ")", None))
        for lst in llst
        ])+(")" if cumo.split(":")[0] not in netan["input"] else "")
        for (flux,llst) in netan["cumo_sys"]["b"][w-1].get(cumo,{}).iteritems()
        ), a="0.")
        for (i,cumo) in enumerate(cumos)
        )
        )
        )
        });
    f.write("""
      RETURN
      END SUBROUTINE fwrv2Abcumo
""");
