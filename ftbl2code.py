#!/usr/bin/env python
# Module for translation of .ftbl file to R or Fortran code

# 2009-09-14 sokol@insa-toulouse.fr : flux.[net|xch] -> [dfc].[nx].flux
#                                     flux.[fwd|rev] -> [fwd|rev].flux
# 2008-12-08 sokol@insa-toulouse.fr : added netan2Rinit()
# 2008-11-25 sokol@insa-toulouse.fr : adapted for reduced cumomer list
# 2008-09-19 sokol@insa-toulouse.fr : initial release
# Copyright 2008 INSA/INRA UMR792, MetaSys
import time;
from tools_ssg import *;
import C13_ftbl;
import copy;
import os;
import sys;
import platform;
from operator import itemgetter;
from itertools import groupby;

global DEBUG;
dirx=os.path.dirname(sys.argv[0]);

def fwrap(text, comment=False):
    """Wraps the text in fortran style, i.e. last char at colomn 72 and
    the following lines are prepended with "     &" (five spaces and ampresand)
    If parameter comment is True then the wrapped text is prepended
    with "C ".
    """
    lent=len(text);
    if comment:
        return "\nC ".join(text[i:min(i+72,lent)] for i in xrange(0, lent, 72));
    else:
        return text[0:72]+("\n     &" if lent > 72 else "")+"\n     &".join(text[i:min(i+66,lent)] for i in xrange(72, lent, 66));

def netan2Abcumo_f(Al, bl, vcumol, minput, f, fwrv2i, incu2i_b1, fortfun="fwrv2Abcumo"):
    """
    Transform cumomer linear sytems collection (from ftbl file)
    to a Fortran subroutine code calculating matrix A and vector b
    in A*x=b for a given weight iw (input Fortran parameter)
    Flux vector fl of all fwd. and rev. fluxes is known from
    Fortran parameter list

    2008-08-26 sokol
    """
    f.write("""
C************************************************************************
C Define subroutine for cumomer matrix A for a given weight iw
C NB: This is an automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.
C
C************************************************************************


      SUBROUTINE %(fortfun)s(fl, nf, x, iw, n, A, b, calcA, calcb)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C Calculate dense matrix for system of linear equations A*x=b
C for cumomer vector x of a given weight iw.
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): composite array of 1, input cumomers and lighter cumomers
C iw (int): weight for which the matrix should be calculated
C n (int): A dimension (n x n)
C Output:
C A (double): array(n,n) representing the system matrix.
C b (double): array(n) representing the system rhs.
      INTEGER            nf
      INTEGER            nx
      INTEGER            iw
      INTEGER            n
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(*)
      DOUBLE PRECISION   A(n,n)
      DOUBLE PRECISION   b(n)
      LOGICAL            calcA
      LOGICAL            calcb
      
C      write(0,*) "%(fortfun)s: start", nf, iw, n
%(fluxe_names)s
%(incu_names)s
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    "fortfun": fortfun,
    "fluxe_names": fwrap("C fluxes: "+join(", ",
     (str(i)+"="+f for (f,i) in sorted(fwrv2i.iteritems()))),
     comment=True),
    "incu_names": fwrap("C incu=c(1,input,x): "+join(", ",
     (str(i)+"="+c for (c,i) in sorted(incu2i_b1.iteritems()))),
     comment=True)
    });
    for (iwl,A) in enumerate(Al):
        w=iwl+1;
        cumos=vcumol[iwl];
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        matrix definition
C        cumos: %(cumos)s
         if (calcA) then
"""%    {
        "iw": w,
        "cumos": join(", ", [(i+1,c) for (i,c) in enumerate(cumos)]),
        });
        # run through the matrix
        for icol in xrange(ncumo):
            f.write("C           (%d,%d) cumo=%s\n" % (icol+1, icol+1, cumos[icol]));
            for irow in xrange(ncumo):
                sign="-" if (irow != icol) else "";
                fli=A[cumos[irow]].get(cumos[icol],[]);
                #if set(fli)-set(fwrv2i.keys()):
                #    raise Exception("A 1ir,1ic=%d,%d: fluxes %s are not in fwrv2i."%
                #        irow+1, icol+1, set(fli)-set(fwrv2i.keys()));
                term=join('+', trd(fli, fwrv2i, 'fl(', ')', None));
                if (not term):
                    continue;
                code="            A(%(ir)d,%(ic)d)=%(sign)s(%(term)s)\n" % {
                "ir": irow+1,
                "ic": icol+1,
                "sign": sign,
                "term": term,
                };
                f.write(fwrap(code));
        # run through the rhs
        f.write("""
         endif
C        right hand side definition
         if (calcb) then
%(b)s
         endif
      endif
""" %   {
        "b": (
        join("\n", (
        fwrap("            b("+str(i+1)+")="+join("+",
        ("fl("+str(fwrv2i[flux])+")*(" +
        joint("+", [
        join("*", trd(lst, incu2i_b1, "x(", ")", None))
        for (imetab,lst) in dlst.iteritems()
        ])+")"
        for (flux,dlst) in bl[iwl].get(cumo,{}).iteritems()
        ), a="0."))
        for (i,cumo) in enumerate(cumos)
        )
        )
        )
        });
    f.write("""
      RETURN
      END SUBROUTINE %(fortfun)s
"""%{"fortfun": fortfun});

def netan2Abcumo_sp(Al, bl, vcumol, minput, f, fwrv2i, incu2i_b1):
    """
    Transform cumomer linear sytems collection (from ftbl file)
    to a R code calculating sparse matrix A and vector b
    in A*x=b for a given weight iw (index in resulting list)
    Flux vector fl of all fwd. and rev. fluxes is known from
    R environement.
    
    Resulting code is a list spAb indexed by cumomer weight
    (cf. generated R comments for details on spAb)
    cumomer vector incu=c(1, xi, xl), xi - input, xl - lighter cumomers.
    
    incu2i_b1 gives i in incu from cumomer name. i=1 corresponds to the constant 1.
    
    2010-10-15 sokol
    """
    nb_cumu=cumsum(len(l) for l in vcumol);
    f.write(
    """
# sparse matrix static parts
# spAb fields:
#  tA - unsigned sparse transpose of cumomer A matrix (off-diagonal part)
#   @i, @p and @x slots are those from Matrix::dgCMatrix class
#  f2ax indexes of fluxes to calculate tA@x slot (cf. fortran
#   f2ax() subroutine in cumo.f)
#  bfpr - unsigned sparse rhs of Ax=b.
#   [(irow, iflux, incu_index1, incu_index2),...]
#   to calculate terms like flux*x1*x2. When there is only one
#   term x, x2 is set to 1
#  ta_fx - unsigned sparse matrix t(dA_df*x)
#   @i run through the fluxes contibuting to a row of dA_df*x
#  x2ta_fx - 1-based indexes of x0=c(0,x) for dA_df*x which is
#   comosed of differences (x_diag - x_off-diag) and (x_diag)
#   when flux is in b term. In this case index of x_off-diag is
#   set to 1 (i.e. 0-value in x0).
#   [irow, ixoff] irow is actually ixdiag
#  tb_f - unsigned sparse matrix t(db_df) with indexes ix1, ix2 for product as in bfpr
#   @i is running along fluxes
#  x2tb_f - 2 row matrix with indexes ix1, ix2 for product as in bfpr
#  tb_x - unsigned sparse transpose of db_dx over x in lighter weights
#   @i runs over lighter cumomers

nb_fwrv=%(n)d;
spAb=list();
nb_rcumos=c(%(lcu)s);
"""%{
    "n": len(fwrv2i),
    "lcu": join(", ", (len(l) for l in vcumol))
});
    # base of cumomers in composed vector incu=c(1, input, xcumo)
    # +1 for c(1,...)
    ba_x=len(incu2i_b1) - sum(len(l) for l in vcumol)+1;
    ba_xw=ba_x; # base for current weigth cumomer in incu
    for (iwl,A) in enumerate(Al):
        w=iwl+1;
        b=bl[iwl];
        cumos=vcumol[iwl];
        ncumo=len(cumos);
        c2i=dict((c,i) for (i,c) in enumerate(cumos));
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise "wrongCumomerNumber";
        l_ia=[]; # list of non zero off-diagonal elements in A / row
        l_ib=[]; # list of non zero elements in b / row
        for irow in xrange(ncumo):
            cr=cumos[irow];
            row=A[cr];
            # atuple is list of (icumo, list(fluxes))
            atuple=[(c2i[c], [fwrv2i[fl] for fl in l])
                for (c,l) in row.iteritems() if c!=cr];
            # btuple is list of (iflux, icumo1, icumo2)
            if cr in b:
                btuple=[(fwrv2i[fl], incu2i_b1[l[0]], (incu2i_b1[l[1]] if len(l)==2 else 1))
                    for (fl, d) in b[cr].iteritems()
                    for (i,l) in d.iteritems()];
            else:
                btuple=[];
            # one list per row
            l_ia.append(atuple);
            l_ib.append(btuple);
        f.write(
"""
w=%(w)d;
nb_c=%(nbc)d;
spAb[[w]]=list();
spAb[[w]]$tA=as(Matrix(0, nrow=nb_c, ncol=nb_c, sparse=T), "dgCMatrix");
spAb[[w]]$tA@i=as.integer(c(%(ia)s));
spAb[[w]]$tA@p=as.integer(c(%(pa)s));
spAb[[w]]$tA@x=rep(0., length(spAb[[w]]$tA@i)); # place holder

spAb[[w]]$f2ta=matrix(as.integer(c(%(f2ta)s)), nrow=2);
spAb[[w]]$bfpr=matrix(as.integer(c(%(bfpr)s)), nrow=4);

spAb[[w]]$ta_fx=as(Matrix(0, nrow=nb_fwrv, ncol=nb_c, sparse=T), "dgCMatrix");
spAb[[w]]$ta_fx@i=as.integer(c(%(ia_fx)s));
spAb[[w]]$ta_fx@p=as.integer(c(%(pa_fx)s));
spAb[[w]]$ta_fx@x=rep(0., length(spAb[[w]]$ta_fx@i)); # place holder

spAb[[w]]$x2ta_fx=matrix(as.integer(c(%(x2ta_fx)s)), nrow=3);

spAb[[w]]$tb_f=as(Matrix(0, nrow=nb_fwrv, ncol=nb_c, sparse=T), "dgCMatrix");
spAb[[w]]$tb_f@i=as.integer(c(%(ibf)s));
spAb[[w]]$tb_f@p=as.integer(c(%(pbf)s));
spAb[[w]]$tb_f@x=rep(0., length(spAb[[w]]$tb_f@i)); # place holder

spAb[[w]]$x2tb_f=matrix(as.integer(c(%(x2tb_f)s)), nrow=2);

spAb[[w]]$tb_x=as(Matrix(0, nrow=ifelse(w>1,sum(nb_rcumos[1:(w-1)]),0), ncol=nb_c, sparse=T), "dgCMatrix");
spAb[[w]]$tb_x@i=as.integer(c(%(ib_x)s));
spAb[[w]]$tb_x@p=as.integer(c(%(pb_x)s));
spAb[[w]]$tb_x@x=rep(0., length(spAb[[w]]$tb_x@i)); # place holder

spAb[[w]]$fx2tb_x=matrix(as.integer(c(%(fx2tb_x)s)), nrow=3);
"""%{
   "w": w,
   "nbc": ncumo,
   "ia": join(", ", [ix
       for lt in l_ia
       for (ix, lf) in sorted(lt)
       ]),
   "pa": join(", ", cumsum(len(lt) for lt in l_ia)),
   "f2ta": join(", ", valval((len(lf), ifl)
       for lt in l_ia
       for (ix, lf) in sorted(lt)
       for ifl in lf)),
   "bfpr": join(", ", valval((ir+1, ifl, i1, i2)
       for (ir, lt) in enumerate(l_ib)
       for (ifl, i1, i2) in lt)),
   "ia_fx": join(", ", (ifl-1
       for (ir, lt) in enumerate(l_ia)
       for ifl in sorted(set([f for (ix, lf) in lt for f in lf]+
       [f for (f,i1,i2) in l_ib[ir]]))
   )), # a flux is not unique in a given row of A, because of split reactions in two identical metabolites
   "pa_fx": join(", ", cumsum(
       len(set([f for ix,lf in lt for f in lf]+
       [f for f,i1,i2 in l_ib[ir]]))
       for (ir, lt) in enumerate(l_ia)
   )),
   "x2ta_fx": join(", ", valval((len(lg), ix, ir+ba_xw+2) # +2=+1 for c(0,incu), +1 for 1-based
       for (ir, lt) in enumerate(l_ia)
       for lg in [list(g) for k, g in
       groupby(sorted([(ifl, ix+ba_xw+2) for ix,lf in lt for ifl in lf]+
       [(ifl, 1) for ifl,i1,i2 in l_ib[ir]]), key=itemgetter(0))]
       for (ifl, ix) in lg
   )),
   "ibf": join(", ", (ifl-1
       for lt in l_ib
       for ifl in sorted(ifl for (ifl, i1, i2) in lt)
   )),
   "pbf": join(", ", cumsum(len(lt) for lt in l_ib)),
   "x2tb_f": join(", ", valval((ix1, ix2)
       for lt in l_ib
       for (ifl, ix1, ix2) in sorted(lt)
   )),
   "ib_x": join(", ", (icu-ba_x-1
       for lt in l_ib
       for icu in sorted(set(icu
       for (ifl, i1, i2) in lt
       for icu in (i1, i2) if icu > ba_x))
   )),
   "pb_x": join(", ", cumsum(len(set(icu
       for (ifl, i1, i2) in lt
       for icu in (i1, i2) if icu > ba_x))
       for lt in l_ib
   )),
   "fx2tb_x": join(", ", valval((len(lg), ifl, icof)
       for lt in l_ib
       for lg in (list(g)
       for k,g in groupby(sorted((icu, ifl, icof)
       for (ifl, i1, i2) in lt
       for (icu, icof) in ((i1,i2), (i2, i1))
       if icu > ba_x), key=itemgetter(0)))
       for (icu, ifl, icof) in lg
   )),
});
        ba_xw+=ncumo;

def netan2Rinit(netan, org, f, fullsys):
    global DEBUG;
    """netan2Rinit(netan, org, f, fullsys)
    Write R code for initialization of all variables before
    cumomer system resolution by khi2 minimization.
    netan is a collection of parsed ftbl information
    f is R code output pointer
    ff is fortran code output pointer
    fullsys=True means write also a code for the full cumomer system
    Return a dictionnary with some python variables:
        "measures": measures,
        "o_mcumos": o_mcumos,
        "cumo2i": cumo2i,
        ...
    """
    # Important python variables:
    # Collections:
    #    netan - (dict) ftbl structured content;
    #    tfallnx - (3-tuple[reac,["d"|"f"|"c"], ["n"|"x"]] list)- total flux
    #    collection;
    #    measures - (dict) exp data;
    #    rAb - (list) reduced linear systems A*x_cumo=b by weight;
    #    scale - unique scale names;
    #    nrow - counts scale names;
    #    o_sc - ordered scale names;
    #    o_meas - ordered measure types;
    # org - (str) prefix of .ftbl  file like "PPP"
    # File names (str):
    #    n_ftbl (descriptor f_ftbl);
    #    n_opt (R code) (f);
    #    n_fort (fortran code) (ff);
    # Counts: nb_fln, nb_flx, nb_fl (dependent fluxes: net, xch, total),
    #         nb_ffn, nb_ffx (free fluxes)
    # Index translators:
    #    fwrv2i - flux names to index in fwrv 1-based;
    #    cumo2i - cumomer names to index in R:x;
    #    ir2isc - mapping measure rows indexes on scale index isc[meas]=ir2isc[meas][ir]
    # Vector names:
    #    cumos (list) - names of R:x;
    #    o_mcumos - cumomers involved in measures;

    # Important R variables:
    # Scalars:
    #    nb_w, nb_cumos, nb_fln, nb_flx, nb_fl (dependent or unknown fluxes),
    #    nb_ffn, nb_ffx, nb_ff (free fluxes),
    #    nb_fcn, nb_fcx, nb_fc (constrained fluxes),
    #    nb_ineq, nb_param, nb_fmn
    # Name vectors:
    #    nm_cumo, nm_fwrv, nm_fallnx, nm_fln, nm_flx, nm_fl, nm_par,
    #    nm_ffn, nm_ffx,
    #    nm_fcn, nm_fcx,
    #    nm_mcumo, nm_fmn
    # Numeric vectors:
    #    fwrv - all fluxes (fwd+rev);
    #    x - all cumomers (weight1+weight2+...);
    #    param - free flux net, free flux xch, scale label, scale mass, scale peak
    #    fcn, fcx, fc,
    #    bp - helps to construct the rhs of flux system
    #    fallnx - complete flux vector (dep, free, constr:net+xch)
    #    bc - helps to construct fallnx
    #    li - inequality vector (mi%*%fallnx>=li)
    #    ir2isc - measur row to scale vector replicator
    #    ci - inequalities for param use (ui%*%param-ci>=0)
    #    measvec,
    #    measinvvar,
    #    irmeas,
    #    fmn
    #    nb_sys - system sizes
    # Matrices:
    #    Afl, qrAfl, invAfl,
    #    p2bfl - helps to construct the rhs of flux system from free fluxes
    #    c2bfl - helps to construct the rhs of flux system from constr. fluxes
    #    mf, md, mc - help to construct fallnx
    #    mi - inequality matrix (ftbl content)
    #    ui - inequality matrix (ready for param use)
    #    measmat - measmat*(x[irmeas];1)=vec of simulated not-yet-scaled measures
    # Functions:
    #    param2fl_x - translate param to flux and cumomer vector (initial approximation)
    #    cumo_cost - cost function (khi2)
    #    cumo_grad - finite difference gradient
    #    fallnx2fwrv - produce fw-rv fluxes from fallnx

    # Main steps:
    #    python var init;
    #    R init;
    #    R function fallnx2fwrv();
    #    python measures, cumos, cumo2i;
    #    fortran code for cumomer systems A*x=b;
    #    R var init;
    #    R Afl, qr(Afl), invAfl;
    #    R param (without scale factors);
    #    R constrained fluxes
    #    R p2bfl, c2bfl, bp
    #    R mf, md, mc
    #    R mi, li
    #    python measure matrix, vector and vars
    #    R ui, ci
    #    R measure matrix, vector, vars
    #    R flux measures

    # header
    f.write("# This is an automatically generated R code. Don't edit.\n");
    f.write("# Generated by \n# "+join(" ", sys.argv)+"\n# at "+time.ctime()+".\n");
    f.write("""
# Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.
""");
    #if DEBUG:
    #    pdb.set_trace();
    res={};
    f.write("""

# get some tools
source("%(dirx)s/tools_ssg.R");
source("%(dirx)s/opt_cumo_tools.R");
dyn.load("%(dirx)s/cumo.%(so)s");
if (TIMEIT) {
   cat("rinit   : ", date(), "\n", sep="");
}
# get runtime arguments if not already set
# opts=strsplit("--sens mc=10", " ")[[1]];
if (length(find("opts"))==0) {
   opts=commandArgs();
}
# profile or not profile?
prof=(length(which(opts=="--prof")) > 0);

# is there a method for sensitivity matrix calculation?
sensitive=which(opts=="--sens");
if (length(sensitive)) {
   sensitive=opts[sensitive[1]+1];
} else {
   sensitive=""; # no sensitivity matrix calculation
}
if (is.na(sensitive)) {
   sensitive=""; # no sensitivity matrix calculation
}
if (substring(sensitive, 1, 3)=="mc=") {
   # read the mc iteration number
   nmc=as.integer(substring(sensitive, 4));
   sensitive="mc";
} else if (sensitive=="mc") {
   nmc=10;
}
#cat("sens=", sensitive, "\\n");
optimize=TRUE;
argopt=which(opts=="--noopt");
if (length(argopt)) {
   optimize=FALSE;
}
fullsys=FALSE;
if (length(which(opts=="--fullsys"))) {
   fullsys=TRUE;
}
initrand=FALSE;
if (length(which(opts=="--irand"))) {
   initrand=TRUE;
}
clownr=1.e-5;
iopt=which(opts=="--clownr")
if (length(iopt)) {
   val=as.numeric(opts[iopt+1]);
   if (!is.na(val)) {
      clownr=val;
   }
}
cupn=1.e5;
iopt=which(opts=="--cupn")
if (length(iopt)) {
   val=as.numeric(opts[iopt+1]);
   if (!is.na(val)) {
      cupn=val;
   }
}
cupx=1-1.e-5;
iopt=which(opts=="--cupx")
if (length(iopt)) {
   val=as.numeric(opts[iopt+1]);
   if (!is.na(val)) {
      cupx=val;
   }
}
# cupx==0 means no upper limit => cupx=1
cupx=ifelse(cupx, cupx, 1);
if (cupx < 0 || cupx > 1) {
   stop(paste("Option '--cupx N' must have N in the interval [0,1]\n",
      "Instead, the value ", cupx, " si given.", sep=""));
}
# end line argument proceeding
# R profiling
if (prof) {
   Rprof("%(proffile)s");
}

# minimization method
validmethods=list("BFGS", "Nelder-Mead", "SANN", "nlsic");
method=which(opts=="--meth");
if (length(method)) {
   method=opts[method[1]+1];
   if (! method %%in%% validmethods) {
      warning(paste("method", method, "is not known."));
      method="nlsic";
   }
} else {
   method="nlsic";
}

# input cumomer vector
xi=c(%(xi)s);
nm_xi=c(%(nm_xi)s);
nb_xi=length(xi);
"""%{
    "xi": join(", ", netan["cumo_input"].values()),
    "nm_xi": join(", ", netan["cumo_input"].keys(), '"', '"'),
#        "sofile": escape(os.path.basename(ff.name)[:-1]+
#            ("dll" if platform.system() == "windows" else "so"), "\\"),
        "dirx": escape(dirx, "\\"),
        "proffile": escape(os.path.basename(f.name)[:-1]+"Rprof", "\\"),
        "so": ("dll" if platform.system() == "windows" else "so"),
});
    netan2R_fl(netan, org, f);
    d=netan2R_rcumo(netan, org, f);
    res.update(d);
    netan["rcumo_sys"]=res["rAb"];
    if fullsys:
        d=netan2R_cumo(netan, org, f);
        res.update(d);
    d=netan2R_meas(netan, org, f);
    res.update(d);
    netan2R_ineq(netan, org, f);
    f.write("""
nb_sys=list(
   free.fluxes=%(ff)s,
   dependent.fluxes=%(depfl)s,
   full.cumomer=c(%(lncumo)s),
   reduced.cumomer=c(%(lnrcumo)s)
);
# carbon length of metabolites
clen=c(%(clen)s);
names(clen)=c(%(nm_metab)s);
"""%{
    "ff": len(netan["flux_free"]["net"])+len(netan["flux_free"]["xch"]),
    "depfl": len(netan["vflux"]["net"])+len(netan["vflux"]["xch"]),
    "lncumo": ",".join(str(len(a)) for a in netan["cumo_sys"]["A"]),
    "lnrcumo": ",".join(str(len(a)) for a in netan["rcumo_sys"]["A"]),
    "clen": join(",", netan["Clen"].values()),
    "nm_metab": join(",", netan["Clen"].keys(), '"', '"')
    });
    return res;

def netan2R_fl(netan, org, f):
    """netan2R_fl(netan, org, f)
    generate R code for flux part
    for more details cf. netan2Rinit()
    """
    # dependent flux counts
    nb_fln=len(netan['vflux']['net']);
    nb_flx=len(netan['vflux']['xch']);
    nb_fl=nb_fln+nb_flx;

    # prepare index translator for free fluxes
    # it will be used in bfl expressions where names like flx.net must
    # be mapped on respecting parameter index
    nb_ffn=len(netan['flux_free']['net']);
    nb_ffx=len(netan['flux_free']['xch']);
    nb_fcn=len(netan['flux_constr']['net']);
    nb_fcx=len(netan['flux_constr']['xch']);
    ffn2iprm=dict(("f.n."+f,(i+1))
        for (f,i) in netan['vflux_free']['net2i'].iteritems());
    ffx2iprm=dict(("f.x."+f,(i+1+nb_ffn))
        for (f,i) in netan['vflux_free']['xch2i'].iteritems());

    # prepare fwrv2i
    fwrv2i=dict((f,i+1) for (f,i) in netan["vflux_fwrv"]["fwrv2i"].iteritems());
    nb_fwrv=len(netan["vflux_fwrv"]["fwrv2i"]);

    # make tuple for complete flux vector d,f,c
    # (name,"d|f|c","n|x")
    tfallnx=zip(
            netan["vflux"]["net"]+
            netan["vflux_free"]["net"]+
            netan["vflux_constr"]["net"]+
            netan["vflux"]["xch"]+
            netan["vflux_free"]["xch"]+
            netan["vflux_constr"]["xch"],

            ["d"]*len(netan["vflux"]["net"])+
            ["f"]*len(netan["vflux_free"]["net"])+
            ["c"]*len(netan["vflux_constr"]["net"])+
            ["d"]*len(netan["vflux"]["xch"])+
            ["f"]*len(netan["vflux_free"]["xch"])+
            ["c"]*len(netan["vflux_constr"]["xch"]),

            ["n"]*len(netan["vflux"]["net"])+
            ["n"]*len(netan["vflux_free"]["net"])+
            ["n"]*len(netan["vflux_constr"]["net"])+
            ["x"]*len(netan["vflux"]["xch"])+
            ["x"]*len(netan["vflux_free"]["xch"])+
            ["x"]*len(netan["vflux_constr"]["xch"]),
            );

    f.write("""
if (TIMEIT) {
   cat("r_flux  : ", date(), "\n", sep="");
}

# custom functions
# produce fw-rv fluxes from fallnx
fallnx2fwrv=function(fallnx) {
   n=length(fallnx);
   # extract and reorder in fwrv order
   net=fallnx[c(%(inet2ifwrv)s)];
   xch=fallnx[c(%(ixch2ifwrv)s)];
   # expansion 0;1 -> 0;+inf of xch (second half of fallnx)
   xch=xch/(1-xch);
   # fw=xch-min(-net,0)
   # rv=xch-min(net,0)
   fwrv=c(xch-pmin(-net,0),xch-pmin(net,0));
   if (DEBUG) {
      n=length(fwrv);
      library(MASS);
      names(fwrv)=nm_fwrv
      write.matrix(fwrv, file="dbg_fwrv.txt", sep="\\t");
   }
   return(fwrv);
}
""" % {
#dyn.load("%(sofile)s");
        "inet2ifwrv": join(", ", (1+
        (netan["vflux"]["net2i"][fl[4:]] if fl[4:] in netan["vflux"]["net2i"]
        else nb_fln+netan["vflux_free"]["net2i"][fl[4:]] if fl[4:] in netan["vflux_free"]["net2i"]
        else nb_fln+nb_ffn+netan["vflux_constr"]["net2i"][fl[4:]])
        for fl in netan["vflux_fwrv"]["fwrv"][:nb_fwrv/2])),
        "ixch2ifwrv": join(", ", (1+len(netan["vflux_fwrv"]["fwrv"])/2+
        (netan["vflux"]["xch2i"][fl[4:]] if fl[4:] in netan["vflux"]["xch2i"]
        else nb_flx+netan["vflux_free"]["xch2i"][fl[4:]] if fl[4:] in netan["vflux_free"]["xch2i"]
        else nb_flx+nb_ffx+netan["vflux_constr"]["xch2i"][fl[4:]])
        for fl in netan["vflux_fwrv"]["fwrv"][:nb_fwrv/2])),
    });
    f.write("""
# fwd-rev flux names
nm_fwrv=c(%(nm_fwrv)s);

# net-xch flux names
nm_fallnx=c(%(nm_fallnx)s);

# initialize the linear system Afl*flnx=bfl (0-weight cumomers)
# unknown net flux names
nm_fln=c(%(nm_fln)s);
nb_fln=length(nm_fln);
# unknown xch flux names
nm_flx=c(%(nm_flx)s);
nb_flx=length(nm_flx);
nm_fl=c(nm_fln, nm_flx);
nb_fl=nb_fln+nb_flx;
# flux matrix
nb_flr=%(nb_flr)d;
if (nb_fl) {
   Afl=matrix(0, nrow=nb_flr, ncol=nb_fl);
"""%{
    "nb_flr": len(netan["Afl"]),
    "nm_fwrv": join(", ", netan["vflux_fwrv"]["fwrv"], '"', '"'),
    "nm_fallnx": join(", ", (join(".", (t[1],t[2],t[0])) for t in tfallnx), '"', '"'),
    "nm_fln": join(", ", netan["vflux"]["net"], '"d.n.', '"'),
    "nm_flx": join(", ", netan["vflux"]["xch"], '"d.x.', '"'),
});
    for (i,row) in enumerate(netan["Afl"]):
        f.write(
"""   Afl[%(i)d, c(%(ic)s)]=c(%(v)s);
"""%{
    "i": i+1,
    "ic": join(", ", (i+1 for (i,v) in enumerate(row) if v!=0.)),
    "v": join(", ", (v for v in row if v!=0.)),
});
    f.write(
"""} else {
   Afl=matrix(0., nb_fl, nb_fl);
}
dimnames(Afl)=list(c(%(nm_rows)s), nm_fl);
if (DEBUG) {
   library(MASS);
   write.matrix(Afl, file="dbg_Afl.txt", sep="\\t");
}
if (nrow(Afl) != ncol(Afl)) {
   write.table(Afl);
   stop(paste("Flux matrix is not square: (", nrow(Afl), "eq x ", ncol(Afl), "unk)\\n",
   "You have to change your choice of free fluxes in the '%(n_ftbl)s' file", sep=""));
}

qrAfl=qr(Afl);

# make sure that free params choice leads to not singular matrix
if (qrAfl$rank != nb_fl) {
   write.table(Afl);
   stop("Flux matrix is singular. You have to change your choice of free fluxes in the '%(n_ftbl)s' file");
}

# inverse flux matrix
invAfl=solve(qrAfl);

# prepare param (\Theta) vector
# order: free flux net, free flux xch, scale label, scale mass, scale peak
param=numeric(0);
nm_par=c();
# free net fluxes
nb_ffn=%(nb_ffn)d;
nm_ffn=c(%(nm_ffn)s);
# starting values for iterations
param=c(param, c(%(ffn)s));
if (nb_ffn) {
   nm_par=c(nm_par, nm_ffn);
}
# free xch fluxes
nb_ffx=%(nb_ffx)d;
nm_ffx=c(%(nm_ffx)s);
# starting values for iterations
param=c(param, c(%(ffx)s));
if (nb_ffx) {
   nm_par=c(nm_par, nm_ffx);
}
nm_ff=c(nm_ffn, nm_ffx);
nb_param=length(param);
if (initrand) {
   param=runif(nb_param);
}
# scaling factors are added to param later

nb_ff=nb_ffn+nb_ffx;
# constrained fluxes
# net
nb_fcn=%(nb_fcn)d;
nm_fcn=c(%(nm_fcn)s);
fcn=c(%(fcn)s);
# xch
nb_fcx=%(nb_fcx)d;
nm_fcx=c(%(nm_fcx)s);
fcx=c(%(fcx)s);
fc=c(fcn, fcx);
nm_fc=c(nm_fcn, nm_fcx)
names(fc)=nm_fc;
nb_fc=nb_fcn+nb_fcx;

# total flux vector fallnx dimension
nb_fallnx=nb_fl+nb_ff+nb_fc;

# all flux cardinals
nb_f=list(nb_fln=nb_fln, nb_flx=nb_flx, nb_fl=nb_fl,
   nb_ffn=nb_ffn, nb_ffx=nb_ffx, nb_ff=nb_ff,
   nb_fcn=nb_fcn, nb_fcx=nb_fcx, nb_fc=nb_fc,
   nb_fallnx=nb_fallnx);

""" % {
    "n_ftbl": escape(org+".ftbl", "\\"),
    "nm_rows": join(", ", netan["vrowAfl"], '"', '"'),
    "nb_ffn": nb_ffn,
    "nb_ffx": nb_ffx,
    "nm_ffn": join(", ", netan["vflux_free"]["net"], '"f.n.', '"'),
    "nm_ffx": join(", ", netan["vflux_free"]["xch"], '"f.x.', '"'),
    "ffn": join(", ", [netan["flux_free"]["net"][fl]
        for fl in netan["vflux_free"]["net"]]),
    "ffx": join(", ", [netan["flux_free"]["xch"][fl]
        for fl in netan["vflux_free"]["xch"]]),
    "nb_fcn": len(netan["flux_constr"]["net"]),
    "nb_fcx": len(netan["flux_constr"]["xch"]),
    "nm_fcn": join(", ", netan["vflux_constr"]["net"], '"c.n.', '"'),
    "nm_fcx": join(", ", netan["vflux_constr"]["xch"], '"c.x.', '"'),
    "fcn": join(", ", [netan["flux_constr"]["net"][fl]
        for fl in netan["vflux_constr"]["net"]]),
    "fcx": join(", ", [netan["flux_constr"]["xch"][fl]
        for fl in netan["vflux_constr"]["xch"]]),
    });
    f.write("""
# prepare p2bfl, c2bfl, cnst2bfl matrices such that p2bfl%*%param[1:nb_ff]+
# c2bfl%*%fc+cnst2bfl=bfl
# replace f.[nx].flx by corresponding param coefficient
p2bfl=matrix(0., nrow=nb_flr, ncol=nb_ff);
# replace c.[nx].flx by corresponding fc coefficient
c2bfl=matrix(0., nrow=nb_flr, ncol=nb_fc);
cnst2bfl=numeric(nb_flr); # can come from equalities
colnames(p2bfl)=nm_par;
colnames(c2bfl)=nm_fc;
""");
    for (i,item) in enumerate(netan["bfl"]):
        if not item:
            continue;
        f.write("\
p2bfl[%(i)d, c(%(if)s)]=c(%(row)s);\n\
c2bfl[%(i)d, c(%(ic)s)]=c(%(rowc)s);\n\
cnst2bfl[%(i)d]=%(rowcnst)s;\n\
"%{
        "i": i+1,
        "if": join(", ", (k for k in item.keys() if k[0:2]=="f."), p='"', s='"'),
        "row": join(", ", (v for (k,v) in item.iteritems() if k[0:2]=="f.")),
        "ic": join(", ", (k for k in item.keys() if k[0:2]=="c."), p='"', s='"'),
        "rowc": join(", ", (v for (k,v) in item.iteritems() if k[0:2]=="c.")),
        "rowcnst": item.get("", 0.),
        });
    f.write("""
bp=c2bfl%*%fc+cnst2bfl;

# intermediate jacobian
dfl_dff = invAfl %*% p2bfl

# prepare mf, md matrices and bd vector
# such that mf%*%ff+md%*%fl+mc%*%fc gives fallnx
# here ff free fluxes (param), fl are dependent fluxes and fc are constrained
# fluxes
mf=matrix(0., nb_fallnx, nb_ff);
dimnames(mf)=list(nm_fallnx, nm_ff);
md=matrix(0., nb_fallnx, nb_fl);
dimnames(md)=list(nm_fallnx, nm_fl);
mc=matrix(0., nb_fallnx, nb_fc);
dimnames(mc)=list(nm_fallnx, nm_fc);

mf[nm_ff, nm_ff]=diag(1., nb_ff);
md[nm_fl, nm_fl]=diag(1., nb_fl);
mc[nm_fc, nm_fc]=diag(1., nb_fc);
""");
    netan["fwrv2i"]=fwrv2i;
    netan["tfallnx"]=tfallnx;
    netan["f2dfc_nx_f"]={
       "net": dict((fl, t+".n."+fl) for (fl,t,nx) in tfallnx if nx=="n"),
       "xch": dict((fl, t+".x."+fl) for (fl,t,nx) in tfallnx if nx=="x"),
    };

def netan2R_meas(netan, org, f):
    """netan2R_meas(netan, org, f)
    generate code for measure treatment
    """
    # prepare python measures
    if "measures" not in netan:
        print("Calculate measures in netan2R_meas.");
        measures=dict();
        for meas in ("label", "mass", "peak"):
            measures[meas]=eval("C13_ftbl.%s_meas2matrix_vec_dev(netan)"%meas);
        netan["measures"]=measures;
    measures=netan["measures"];
    #aff("got measures in netan2R_meas", measures);##
    # get scaling factors and their indexes, measure matrices, and measured cumomer value vector
    scale={"label": {}, "mass": {}, "peak": {}}; # for unique scale names
    nrow={"label": {}, "mass": {}, "peak": {}}; # for counting scale names
    o_sc={"label": {}, "mass": {}, "peak": {}}; # for ordered unique scale names
    o_meas=measures.keys(); # ordered measure types
    o_meas.sort();

    if DEBUG:
        pdb.set_trace();

    ir2isc={"label": [], "mass": [], "peak": []}; # for mapping measure rows indexes on scale index
    # we want to use it in python like isc[meas]=ir2isc[meas][ir]
    for meas in o_meas:
        # get unique scaling factors
        # and count rows in each group
        # row["scale"] is "metab;group" (metab name may be fake here)
        for (i,row) in enumerate(measures[meas]["mat"]):
            scale[meas][row["scale"]]=0.;
            nrow[meas][row["scale"]]=nrow[meas].get(row["scale"],0.)+1;
        # remove groups having only one measure in them
        for (k,n) in list(nrow[meas].iteritems()):
            if n<2:
                del(scale[meas][k]);
        # order scaling factor
        o_sc[meas]=scale[meas].keys();
        o_sc[meas].sort();
        # map a measure rows (card:n) on corresponding scaling factor (card:1)
        # if a row has not scale factor it is scaled with factor 1
        # vector having scaling parameters is formed like
        # c(1,param);
        ir2isc[meas]=[-1]*len(measures[meas]["mat"]);
        for (i,row) in enumerate(measures[meas]["mat"]):
            if row["scale"] in scale[meas]:
                ir2isc[meas][i]=o_sc[meas].index(row["scale"]);

        # measured value vector is in measures[meas]["vec"]
        # measured dev vector is in measures[meas]["dev"]

    if DEBUG:
        pdb.set_trace();

    # create R equivalent structures with indices for scaling
    f.write("""
if (TIMEIT) {
   cat("measure : ", date(), "\n", sep="");
}
# make place for scaling factors
""");
    for meas in o_meas:
        if not o_sc[meas]:
            continue;
        f.write("""
# %(meas)s
# initial values for scales are set later
param=c(param,%(sc)s);
nm_par=c(nm_par,c(%(sc_names)s));
""" % {
        "meas": meas,
        "sc": join(", ", (scale[meas][sc] for sc in o_sc[meas])),
        "sc_names": join(", ", o_sc[meas], '"'+meas+';', '"'),
        });

    f.write("""
nb_param=length(param);
nb_sc=nb_param-nb_ff;
# indices mapping from scaling to measure matrix row
# c(1,par)[ir2isc] replicates scale parameters
# for corresponding rows of measure matrix
ir2isc=numeric(0);
""");
    base_isc=1;
    for meas in o_meas:
        f.write("""
# %(meas)s
ir2isc=c(ir2isc,c(%(ir2isc)s));
""" % {
        "nsc_meas": len(scale[meas]),
        "meas": meas,
        "sc_names": join(", ", o_sc[meas], '"', '"'),
        "ir2isc": join(", ", ((str(ir2isc[meas][ir]+base_isc) if ir2isc[meas][ir]>=0 else -1)
            for ir in xrange(len(ir2isc[meas]))))
        });
        base_isc=base_isc+len(scale[meas]);

    f.write("""
# shift indices by nb_ff+1
ir2isc[ir2isc>0]=ir2isc[ir2isc>0]+nb_ff+1;
ir2isc[ir2isc<=0]=1;
""");
    # get the full dict of non zero cumomers involved in measures
    # cumo=metab:icumo where icumo is in [1;2^Clen]
    if DEBUG:
        pdb.set_trace();
    meas_cumos={};
    for meas in o_meas:
        for row in measures[meas]["mat"]:
            metab=row["metab"];
            meas_cumos.update((metab+":"+str(icumo), "") for icumo in row["coefs"].keys() if icumo != 0);

    # order involved cumomers
    o_mcumos=meas_cumos.keys();
    o_mcumos.sort();
    imcumo2i=dict((cumo, i) for (i, cumo) in enumerate(o_mcumos));
    nb_mcumo=len(o_mcumos);
    f.write("""
# make measure matrix
# matrix is "densified" such that
# measmat*(xr[irmeas];1)vec of simulated not-yet-scaled measures
# where irmeas is the R-index of involved in measures cumomers
# all but 0. Coefficients of 0-cumomers, by defenition equal to 1,
# are all regrouped in the last matrix column.
nm_meas=c(%(idmeas)s);
nb_meas=length(nm_meas);
measmat=matrix(0., nb_meas, %(ncol)d);
measvec=c(%(vmeas)s);
measinvvar=c(%(invvar)s);
irmeas=c(%(irmeas)s);
nm_mcumo=c(%(mcumos)s);
dimnames(measmat)=list(nm_meas, c(nm_mcumo, "#x*"));
names(measvec)=nm_meas;
names(measinvvar)=nm_meas;
"""%{
    "nrow": len([measures[meas]["vec"] for meas in measures]),
    "ncol": (nb_mcumo+1),
    "irmeas": join(", ", trd(o_mcumos,netan["rcumo2i"],a="")),
    "mcumos": join(", ", o_mcumos, '"', '"'),
    "idmeas": join(", ", (row["id"] for row in
        valval(measures[o]["mat"] for o in o_meas)),
        p='"', s='"'),
    "vmeas": join(", ", valval(measures[o]["vec"] for o in o_meas)),
    "invvar": join(", ", (1./sd/sd for sd in valval(measures[o]["dev"]
        for o in o_meas))),
    });

    # get coeffs in the order above with their corresponding indices from total cumomer vector
    i=0;
    for meas in o_meas:
        if not measures[meas]["mat"]:
            continue;
        #print("meas="+meas+"; mat="+str(measures[meas]["mat"]));##
        for row in measures[meas]["mat"]:
            i+=1;
            metab=row["metab"];
            f.write(
"""measmat[%(i)d, c(%(cumos)s)]=c(%(coefs)s);
"""%{
    "i": i,
    "cumos": join(", ", ((metab+":"+str(k) if k else "#x*")
        for k in row["coefs"].keys()), p='"', s='"'),
    "coefs": join(", ", row["coefs"].values()),
});

    f.write("""
# prepare flux measures
nb_fmn=%(nb_fmn)d;
nm_fmn=c(%(nm_fmn)s);

# measured values
fmn=c(%(fmn)s);

# inverse of variance for flux measures
invfmnvar=c(%(invfmnvar)s);

# indices for measured fluxes
# fallnx[ifmn]=>fmn, here fallnx is complete net|xch flux vector
# combining unknown (dependent), free and constrainded fluxes
ifmn=c(%(ifmn)s);

"""%{
    "nb_fmn": len(netan["vflux_meas"]["net"]),
    "nm_fmn": join(", ", netan["vflux_meas"]["net"], '"f.n.', '"'),
    "fmn": join(", ", (netan["flux_measured"][fl]["val"]
        for fl in netan["vflux_meas"]["net"])),
    "invfmnvar": join(", ", (1./(netan["flux_measured"][fl]["dev"]**2)
        for fl in netan["vflux_meas"]["net"])),
    "ifmn": join(", ", (1+netan["vflux_compl"]["net2i"][fl]
        for fl in netan["vflux_meas"]["net"])),
    });
    return {
        "o_meas": o_meas,
        "measures": measures,
        "o_mcumos": o_mcumos,
        "imcumo2i": imcumo2i,
    };

def netan2R_rcumo(netan, org, f):
    # prepare reduced python systems
    rAb=C13_ftbl.rcumo_sys(netan);
    # full matrix is Ab=netan["cumo_sys"]

    # prune ordered cumomer list in reverse order
    # so that deleted item does not change the index
    # for the rest items to prune
    if "vrcumo" not in netan:
        netan["vrcumo"]=copy.deepcopy(netan["vcumo"]);
        for i in xrange(len(netan["vrcumo"]),len(rAb["A"]),-1):
            # delete extra weight systems
            del(netan["vrcumo"][i-1]);
        for (iw,cumol) in enumerate(netan["vrcumo"]):
            for i in xrange(len(cumol), 0, -1):
                i-=1;
                if cumol[i] not in rAb["A"][iw]:
                    #print "prune", i, cumol[i];##
                    del(cumol[i]);
    # prepare cumo2i
    # translate cumoname like A:7 to its index in R vector of cumomers
    rcumos=list(valval(netan["vrcumo"]));
    rcumo2i=dict((c,i+1) for (i,c) in enumerate(rcumos));
    # composit cumomer vector incu=c(1,xi,xc)
    incu2i_b1=dict((c,i+2) for (i,c) in enumerate(netan["cumo_input"].keys()+rcumos));
    # write code for reduced cumomer systems
    #netan2Abcumo_f(rAb["A"], rAb["b"],
    #    netan["vrcumo"], netan["input"], ff, netan["fwrv2i"], incu2i_b1, "fwrv2rAbcumo");
    netan2Abcumo_sp(rAb["A"], rAb["b"],
        netan["vrcumo"], netan["input"], f, netan["fwrv2i"], incu2i_b1);
    #netan2j_rhs_f(rAb["A"], rAb["b"],
    #    netan["vrcumo"], netan["input"], ff, netan["fwrv2i"], rcumo2i, incu2i_b1, "frj_rhs");
    # write R constants and names
    f.write("""
# weight count
nb_rw=%(nb_rw)d;
# cumomer count by weight;
nb_rcumos=c(%(nb_rc)s);
# cumo names
nm_rcumo=c(%(nm_rcumo)s);
# composite cumomer vector incu c(1, xi, xc) names
nm_incu=c("", nm_xi, nm_rcumo); # constant 1 has empty name
"""%{
    "nb_rw": len(rAb["A"]),
    "nb_rc": join(", ", (len(a) for a in rAb["A"])),
    "nm_rcumo": join(", ", valval(netan['vrcumo']), '"', '"'),
});
    netan["rcumo2i"]=rcumo2i;
    return {
        "rcumo2i": rcumo2i,
        "rAb": rAb,
    };

def netan2R_cumo(netan, org, f):
    """netan2R_cumo(netan, org, f)->dict
    generate fortran code for matrices
    """
    # prepare cumo2i
    # translate cumoname like A:7 to its index in R vector of cumomers
    cumos=list(valval(netan["vcumo"]));
    cumo2i=dict((c,i+1) for (i,c) in enumerate(cumos));
    # composite cumomer vector
    incu2i_b1=dict((c,i+2) for (i,c) in enumerate(netan["cumo_input"].keys()+cumos));

    # write fortran code for complete cumomer systems
    #netan2Abcumo_f(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
    #    netan["vcumo"], netan["input"], ff, netan["fwrv2i"], cumo2i, incu2i_b1, "fwrv2Abcumo");
    #netan2j_rhs_f(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
    #    netan["vcumo"], netan["input"], ff, netan["fwrv2i"], cumo2i, incu2i_b1, "fj_rhs");
    netan2Abcumo_sp(netan["cumo_sys"]["A"], netan["cumo_sys"]["b"],
        netan["vcumo"], netan["input"], f, netan["fwrv2i"], incu2i_b1);
    # write R constants and names
    f.write("""
if (TIMEIT) {
   cat("rcumo   : ", date(), "\n", sep="");
}

# weight count
nb_w=%(nb_w)d;

# cumomer count by weight;
nb_cumos=c(%(nb_c)s);

# cumo names
nm_cumo=c(%(nm_cumo)s);
"""%{
    "nb_w": len(netan["cumo_sys"]["A"]),
    "nb_c": join(", ", (len(a) for a in netan["cumo_sys"]["A"])),
    "nm_cumo": join(", ", valval(netan['vcumo']), '"', '"'),
});
    netan["cumo2i"]=cumo2i;
    return {
        "cumo2i": cumo2i,
    };

def netan2R_ineq(netan, org, f):
    """netan2R_ineq(netan, org, f)
    generate inequality code
    """
    # ex: netan["flux_inequal"]
    # {'net': [], 'xch': [('0.85', '>=', {'v2': '+1.'})]}
    tfallnx=netan["tfallnx"];
    f2dfc_nx_f=netan["f2dfc_nx_f"];
    #dict2kvh(dict((i,t) for (i,t) in enumerate(tfallnx)), "tfallnx.kvh");##
    nb_ineq=len(netan["flux_inequal"]["net"])+len(netan["flux_inequal"]["xch"]);
    f.write("""
if (TIMEIT) {
   cat("ineq    : ", date(), "\n", sep="");
}
# prepare mi matrix and li vector
# such that mi*fallnx>=li corresponds
# to the inequalities given in ftbl file
nb_ineq=%(nb_ineq)s;
mi=matrix(0., nrow=nb_ineq, ncol=nb_fallnx);
li=numeric(nb_ineq);
nm_i=c(c(%(nm_in)s), c(%(nm_ix)s));
dimnames(mi)=list(nm_i, nm_fallnx);
""" % {
   "nb_ineq": nb_ineq,
   "nm_in": join(", ", (join("", (ineq[0], ineq[1], join("+",
        ((str(fa)+"*" if fa != 1. else "")+fl
        for (fl,fa) in ineq[2].iteritems()))))
        for ineq in netan["flux_inequal"]["net"]), p='"n:', s='"'),
   "nm_ix": join(", ", (join("", (ineq[0], ineq[1], join("+",
        ((str(fa)+"*" if fa != 1. else "")+fl
        for (fl,fa) in ineq[2].iteritems()))))
        for ineq in netan["flux_inequal"]["xch"]), p='"x:', s='"'),
});
    
    for (i, ineq) in enumerate(netan["flux_inequal"]["net"]):
        f.write(
"""mi[%(i)s, c(%(f)s)]=%(sign)sc(%(coef)s);
li[%(i)s]=%(sign)s%(li)g;
"""%{
    # as R inequality is always ">=" we have to inverse the sign for "<=" in ftbl
    "i": i+1,
    "sign": ("" if ineq[1]=="<=" or ineq[1]=="=<" else "-"),
    "f": join(", ", trd(ineq[2].keys(), f2dfc_nx_f["net"]), p='"', s='"'),
    "coef": join(", ", ineq[2].values()),
    "li": ineq[0],
    });
    for (i, ineq) in enumerate(netan["flux_inequal"]["xch"]):
        f.write(
"""mi[%(i)s, c(%(f)s)]=%(sign)sc(%(coef)s);
li[%(i)s]=%(sign)s%(li)g;
"""%{
    # as R inequality is always ">=" we have to inverse the sign for "<=" in ftbl
    "i": len(netan["flux_inequal"]["net"])+i+1,
    "sign": ("" if ineq[1]=="<=" or ineq[1]=="=<" else "-"),
    "f": join(", ", trd(ineq[2].keys(), f2dfc_nx_f["xch"]), p='"', s='"'),
    "coef": join(", ", ineq[2].values()),
    "li": ineq[0],
    });

    nb_fdx=len(netan["vflux"]["xch"]);
    nb_ffx=len(netan["vflux_free"]["xch"]);
    f.write("""
# add standard limits on [df].xch [0;cupx]
nb_tmp=nrow(mi);
nb_fx=nb_flx+nb_ffx;
if (nb_fx) {
   mi=rbind(mi, matrix(0, nrow=2*nb_fx, ncol=nb_fallnx));
   if (nb_flx)
      nm_i=c(nm_i, paste(nm_flx, ">=0", sep=""));
   if (nb_ffx)
      nm_i=c(nm_i, paste(nm_ffx, ">=0", sep=""));
   if (nb_flx)
      nm_i=c(nm_i, paste(nm_flx, "<=", cupx, sep=""));
   if (nb_ffx)
      nm_i=c(nm_i, paste(nm_ffx, "<=", cupx, sep=""));
   li=c(li, rep(0, nb_fx), rep(-cupx, nb_fx));
   mi[nb_tmp+(1:nb_fx),c(nm_flx, nm_ffx)]=diag(1., nb_fx);
   mi[nb_tmp+nb_fx+(1:nb_fx),c(nm_flx, nm_ffx)]=diag(-1., nb_fx);
}
""");
    
    nb_notrev=len(netan["notrev"]);
    f.write("""
if (clownr!=0) {
   # add low limits on net >= 1.e-5 for not reversible reactions
   nb_tmp=nrow(mi);
   nm_tmp=c(%(nm_notrev)s);
   mi=rbind(mi, matrix(0, nrow=%(nb_notrev)d, ncol=nb_fallnx));
   nm_i=c(nm_i, paste(nm_tmp, ">=", clownr));
   mi[nb_tmp+(1:%(nb_notrev)d), nm_tmp]=diag(1., %(nb_notrev)d);
   li=c(li, rep(1.e-5, %(nb_notrev)d));
}
nb_fn=nb_fln+nb_ffn
if (cupn != 0 && nb_fn) {
   # add upper limits on [df].net <= 1.e5 for net fluxes
   nb_tmp=nrow(mi);
   mi=rbind(mi, matrix(0, nrow=nb_fn, ncol=nb_fallnx));
   if (nb_fln)
      nm_i=c(nm_i, paste(nm_fln, "<=", cupn, sep=""));
   if (nb_ffn)
      nm_i=c(nm_i, paste(nm_ffn, "<=", cupn, sep=""));
   li=c(li, rep(-cupn, nb_fn));
   mi[nb_tmp+(1:nb_fn),c(nm_fln, nm_ffn)]=diag(-1., nb_fn);
}

"""%{
   "nb_notrev": nb_notrev,
   "nm_notrev": join(", ", (t+"."+nxi+"."+fli
      for (fli,t,nxi) in tfallnx if nxi=="n" and fli in netan["notrev"]),
      p='"', s='"'),
});

    f.write("nb_ineq=NROW(li);\n");
    f.write("""
dimnames(mi)=list(nm_i, nm_fallnx);
names(li)=nm_i;
# prepare ui matrix and ci vector for optimisation
# ui%*%param-ci>=0
# it is composed of explicite inequalities from ftbl
# and permanent inequalities 0<=xch<=0.999 and scale>=0

# constraints such that ui%*%param[1:nb_ff]-ci>=0
ui=mi%*%(md%*%invAfl%*%p2bfl+mf);
ci=li-mi%*%(md%*%invAfl%*%(c2bfl%*%fc+cnst2bfl) + mc%*%fc);

# remove all zero rows in ui (constrained fluxes with fixed values)
# find zero indexes
zi=apply(ui,1,function(v){r=range(v); return(max(abs(v))<=1.e-14)});
if (all(ci[zi]<=1.e-14)) {
   ui=ui[!zi,];
   ci=ci[!zi];
   nm_i=nm_i[!zi];
} else {
   cat("The following constant inequalities are not satisfied:\\n", file=stderr());
   cat(nm_i[zi][ci[zi]>1.e-14], sep="\\n", file=stderr());
   stop();
}
# complete ui by zero columns corresponding to scale params
ui=cbind(ui, matrix(0., NROW(ui), nb_param-nb_ff));

if (nb_param>nb_ff) {
   # complete ui by scales >=0
   ui=rbind(ui, cbind(matrix(0, nb_param-nb_ff, nb_ff), diag(1, nb_param-nb_ff)));
   ci=c(ci,rep(0., nb_param-nb_ff));
   nm_i=c(nm_i, paste(nm_par[(nb_ff+1):nb_param], ">=0", sep=""));
   dimnames(ui)[[1]]=nm_i;
   names(ci)=nm_i;
}

# remove redundant inequalities
nb_i=nrow(ui);
ired=c();
for (i in 1:(nb_i-1)) {
   nmref=nm_i[i];
   for (j in setdiff((i+1):nb_i, ired)) {
      if (all(ui[j,]==ui[i,]) && ci[i]==ci[j]) {
         # redundancy
         cat("inequality ", nm_i[j], " redundant with ", nmref, " is removed.\n", sep="");
         ired=c(ired, j);
      }
   }
}
if (!is.null(ired)) {
   # remove all ired inequalities
   ui=ui[-ired,];
   ci=ci[-ired];
   nm_i=nm_i[-ired];
}
""");

def netan2j_rhs_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, incu2i_b1, fortfun="fj_rhs"):
    """
    netan2j_rhs_f(Al, bl, vcumol, minput, f, fwrv2i, cumo2i, fortfun="fj_rhs")->None
    minput - input metabolites
    Write a Fortran subroutine calculating term by term j_rhs in the
    the Jacobian dx_df (or x_f) derived from cumomer balances
    for a given weight iw (input Fortran parameter)
    Flux vector fl is known from Fortran parameter list

    2009-07-24 sokol
    """
    f.write("""
C************************************************************************
C Define subroutine for jacobian rhs calculation for a given weight iw
C NB: This is an automatically generated code. Don't edit
C Generated by
C %(cmd)s
C at %(date)s
C Copyright 2009, INRA, France.
C
C************************************************************************


      SUBROUTINE %(fortfun)s(fl, nf, x, xw, x_f, nx, nxw, iw, j_rhs, b_x)

      IMPLICIT NONE
C-------------------------------------------------------------------------
C For a given weight iw, update term by term j_rhs matrix
C for cumomer vector x and x_f of previous weights.
C The term b_x*x_f is not included in j_rhs, only b_x
C is calculated and returned. It is left to the care of the user
C to integrate this term to j_rhs
C
C Input:
C fl (double): array of forward-reverse fluxes 
C nf (int): dimension of previous array
C x (double): composite array of input and lighter cumomers
C x_f (double): matrix (nx, nf) with weight lighter than current iw
C nx (int): x  and x_f column dimension
C nxw (int): cumomer number for current weight iw
C iw (int): weight for which the matrix should be calculated
C j_rhs (double): array(nxw x nf) initial value of right hand side
C   matrix.
C Output:
C j_rhs (double): array(n x nf)
C b_x (double): array(nxw x nx)
      INTEGER            nf
      INTEGER            nx
      INTEGER            nxw
      INTEGER            iw
      DOUBLE PRECISION   fl(nf)
      DOUBLE PRECISION   x(nx)
      DOUBLE PRECISION   xw(nxw)
      DOUBLE PRECISION   x_f(nx,nf)
      DOUBLE PRECISION   j_rhs(nxw,nf)
      DOUBLE PRECISION   b_x(nxw,nx)
      
C      write(0,*) "%(fortfun)s: start", nf, nx, nxw, iw,
C fluxes: %(fl)s
C composite x: %(x)s
    """%{
    "cmd": join(" ", sys.argv),
    "date": time.ctime(),
    "fortfun": fortfun,
    "fl": str(sorted((i,f) for (f,i) in fwrv2i.iteritems())),
    "x": str(sorted((i,c) for (c,i) in incu2i_b1.iteritems())),
    });
    for (iwl,A) in enumerate(Al):
        b=bl[iwl];
        w=iwl+1;
        cumos=vcumol[iwl];
        # current weight cumomer numbering for xw vector
        wcumo2i=dict((c,i+1) for (i,c) in enumerate(cumos));
        #print ("wcumo2i", wcumo2i);
        ncumo=len(cumos);
        #d=[c for c in netan['cumo_sys']['A'][w-1] if not c in cumos]
        if ncumo != len(A):
            raise Exception("Wrong cumomer number");
        #metab_paths=netan['metab_paths']; # ordered by pathways
        f.write("""
      if (iw .EQ. %(iw)d) then
C        dA_dv * cumos definition
C        xw: %(cumos)s
"""%    {
        "iw": w,
        "cumos": join(", ", ((i+1,c) for (i,c) in enumerate(cumos))),
        });
        # run through the matrix A
        for irow in xrange(ncumo):
            # for a given row and vi, A_vi*x is just a sum of x concerned by vi
            # in this row.
            # This sum is added to j_rhs[irow, vi]
            visum={};
            f.write("""
C        ir=%d, cumo=%s\n"""%(irow+1, cumos[irow]));
            xsum="";
            for cumo in A[cumos[irow]].keys():
                icol=wcumo2i[cumo]-1; # back to zero based
                sign="+" if (irow != icol) else "-";
                for fl in A[cumos[irow]][cumo]:
                    visum[fl]=visum.get(fl, {"+": [], "-": []});
                    visum[fl][sign].append(cumos[icol]);
            # update irow in j_rhs with -a_v_x
            for fl in visum:
                for sign in visum[fl]:
                    term=join('+', trd(visum[fl][sign], wcumo2i, 'xw(', ')', None));
                    if not term:
                        continue;
                    code="         j_rhs(%(ir)d,%(ic)d)=j_rhs(%(ir)d,%(ic)d)%(sign)s(%(term)s)\n" % {
                        "ir": irow+1,
                        "ic": fwrv2i[fl],
                        "sign": sign,
                        "term": term,
                        };
                    f.write(fwrap(code));
            # b_v: run through the b
            if cumos[irow] not in b:
                continue;
            f.write("""
C        b_v term""");
            brow=b[cumos[irow]];
            for (fl, dlst) in brow.iteritems():
                f.write(fwrap("""
         j_rhs(%(ir)d,%(ic)d)=j_rhs(%(ir)d,%(ic)d)+%(b_v)s
""" %           {
                    "ir": irow+1,
                    "ic": fwrv2i[fl],
                    "b_v": joint("+", [
                        join("*", trd(lst, incu2i_b1, "x(", ")"))
                        for (imetab,lst) in dlst.iteritems()
        ])}));
            if iwl > 0:
                f.write("""
C        b_x term""");
            for (fl, dlst) in brow.iteritems():
                ifl=fwrv2i[fl];
                b_x="fl(%d)"%ifl;
                csum=dict();
                for (imetab,lst) in dlst.iteritems():
                    if len(lst)==1:
                        # input cumomer, skip
                        continue;
                    # derive the cumo products item*factor
                    for (item,ifct) in ((0,1), (1,0)):
                        if lst[item] in cumo2i:
                            # the item is a variable cumomer (not input) so it's derivable
                            factor=("x(%d)"%incu2i_b1[lst[ifct]]);
                            ici=cumo2i[lst[item]]; # index of cumomer item
                            if ici in csum:
                                csum[ici].append(factor);
                            else:
                                csum[ici]=[factor];
                if not csum:
                    continue;
                for (ix,factor) in csum.iteritems():
                    f.write(fwrap("""
         b_x(%(ir)d,%(ic)d)=b_x(%(ir)d,%(ic)d)+%(b_x)s*(%(factor)s)
""" %   {
        "ir": irow+1,
        "ic": ix,
        "b_x": b_x,
        "factor": join("+", factor)}));
        f.write("""
      endif
"""); # end of fortran if on iw
    f.write("""
      RETURN
      END SUBROUTINE %(fortfun)s
"""%{"fortfun": fortfun});
