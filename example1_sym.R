# This is automatically generated R code. Don't edit.
# Generated by ./ftbl2symAb.py at Tue Jun 10 15:43:07 2008.

# Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.

# init some constants
nw=2; # maximal cumomer weight

# Initialize the lists if necessary (Ac is used as indicator for all other lists)
if (! "Ac" %in% ls()) {
#   require(Matrix);
   Al=Ac=Au=spA=b=cumos=ncumo=nxl=nxu=list();
   nx=0;  # length of cumomer vector x (each weight will add a chunk)
   # x is global for all iw thus we can calculate b in simple way
   x=vector("numeric",0);
}

# assign A and b weight by weight;

iw=1;
if (length(Ac) < iw) {
   # initialiaze cumomer names
   cumos[[iw]]=c("A:1","B:1","C:2","B:2","C:1","A:2");
   ncumo[[iw]]=length(cumos[[iw]]);
   # init cumomer dependent vectors
   Al[[iw]]=Ac[[iw]]=Au[[iw]]=b[[iw]]=vector("numeric", ncumo[[iw]]);
   x=c(x,vector("numeric", ncumo[[iw]]));
   nxl[iw]=nx+1;
   nxu[iw]=nx+ncumo[[iw]];
   nx=nx+ncumo[[iw]];
   # ... and sparse part of the matrix
#   spA[[iw]]=Matrix(0., ncumo[[iw]], ncumo[[iw]]);
   spA[[iw]]=matrix(0., ncumo[[iw]], ncumo[[iw]]);
##debug
#print(paste("init iw=", iw));
#print(cumos);
#print(Ac);
#print(spA);
#print(b);
}
# central diagonal
Ac[[iw]]=c(1.,fl["v2.fwd"]+fl["v3.fwd"],fl["v2.rev"]+fl["v4.fwd"],fl["v2.fwd"]+fl["v3.fwd"],fl["v2.rev"]+fl["v4.fwd"],1.);
# lower diagonal (first element is a garbage)
Al[[iw]]=-c(0.,fl["v1.fwd"],fl["v3.fwd"],fl["v2.rev"],fl["v3.fwd"],0.);
# upper diagonal (last element is a garbage)
Au[[iw]]=-c(0.,0.,fl["v2.fwd"],0.,0.,0.);

# sparse part (if any)
spA[[iw]][5,2]=-(fl["v2.fwd"]);
spA[[iw]][2,5]=-(fl["v2.rev"]);
spA[[iw]][4,6]=-(fl["v1.fwd"]);

# right hand side term b
b[[iw]]=c(0.011,0.,0.,0.,0.,0.5);
names(Al[[iw]])=names(Ac[[iw]])=names(Au[[iw]])=names(b[[iw]])=cumos[[iw]];
dimnames(spA[[iw]])=list(cumos[[iw]],cumos[[iw]]);
names(x)[nxl[[iw]]:nxu[[iw]]]=cumos[[iw]];
## debug
#print(iw);
#print("Ac");
#print(Ac);
#print("b");
#print(b);

# solve the system A[[iw]]*x[<iw part>]=b[[iw]];
x[nxl[[iw]]:nxu[[iw]]]=trisparse_solv(Al[[iw]],Ac[[iw]],Au[[iw]],spA[[iw]],b[[iw]]);
#print("x");
#print(x);

iw=2;
if (length(Ac) < iw) {
   # initialiaze cumomer names
   cumos[[iw]]=c("A:3","B:3","C:3");
   ncumo[[iw]]=length(cumos[[iw]]);
   # init cumomer dependent vectors
   Al[[iw]]=Ac[[iw]]=Au[[iw]]=b[[iw]]=vector("numeric", ncumo[[iw]]);
   x=c(x,vector("numeric", ncumo[[iw]]));
   nxl[iw]=nx+1;
   nxu[iw]=nx+ncumo[[iw]];
   nx=nx+ncumo[[iw]];
   # ... and sparse part of the matrix
#   spA[[iw]]=Matrix(0., ncumo[[iw]], ncumo[[iw]]);
   spA[[iw]]=matrix(0., ncumo[[iw]], ncumo[[iw]]);
##debug
#print(paste("init iw=", iw));
#print(cumos);
#print(Ac);
#print(spA);
#print(b);
}
# central diagonal
Ac[[iw]]=c(1.,fl["v2.fwd"]+fl["v3.fwd"],fl["v2.rev"]+fl["v4.fwd"]);
# lower diagonal (first element is a garbage)
Al[[iw]]=-c(0.,fl["v1.fwd"],fl["v2.fwd"]+fl["v3.fwd"]);
# upper diagonal (last element is a garbage)
Au[[iw]]=-c(0.,fl["v2.rev"],0.);

# sparse part (if any)

# right hand side term b
b[[iw]]=c(0.0,0.,0.);
names(Al[[iw]])=names(Ac[[iw]])=names(Au[[iw]])=names(b[[iw]])=cumos[[iw]];
dimnames(spA[[iw]])=list(cumos[[iw]],cumos[[iw]]);
names(x)[nxl[[iw]]:nxu[[iw]]]=cumos[[iw]];
## debug
#print(iw);
#print("Ac");
#print(Ac);
#print("b");
#print(b);

# solve the system A[[iw]]*x[<iw part>]=b[[iw]];
x[nxl[[iw]]:nxu[[iw]]]=trisparse_solv(Al[[iw]],Ac[[iw]],Au[[iw]],spA[[iw]],b[[iw]]);
#print("x");
#print(x);
