# This is automatically generated R code. Don't edit.
# Generated by ./ftbl2symAb.py at Fri Apr 18 13:33:20 2008.

# Copyright Metasys, INSA/INRA UMR 792, Toulouse, France.

# init some constants
nw=2; # maximal cumomer weight

# Initialize the lists if necessary (Ac is used as indicator for all other lists)
if (! "Ac" %in% ls()) {
   require(Matrix);
   Al=Ac=Au=spA=b=cumos=ncumo=list();
   nx=0;  # length of cumomer vector x (each weight will add a chunk)
   x=vector("numeric",0);
}

# assign variables weight by weight;

iw=1;
if (length(Ac) < iw) {
   # initialiaze cumomer names
   cumos[[iw]]=c("B:2","C:1","B:1","C:2");
   ncumo[[iw]]=length(cumos);
   # init cumomer dependent vectors
   Al[[iw]]=Ac[[iw]]=Au[[iw]]=b[[iw]]=vector("numeric", ncumo[[iw]]);
   x=c(x,vector("numeric", ncumo[[iw]]);
   names(Al[[iw]])=names(Ac[[iw]])=names(Au[[iw]])=names(b[[iw]])=cumos[[iw]];
   names(x[(nx+1):(nx+ncumo[[iw]])]=cumos[[iw]];
   # ... and sparse part of the matrix
   spA[[iw]]=Matrix(0., ncumo[[iw]], ncumo[[iw]]);
   dimnames(spA[[iw]])=list(cumos[[iw]],cumos[[iw]]);
}
# central diagonal
Ac[[iw]]=c(v2.fwd+v3.fwd,v4.fwd+v2.rev,v2.fwd+v3.fwd,v4.fwd+v2.rev);
# lower diagonal (first element is a garbage)
Al[[iw]]=c(-(v2.rev),-(v3.fwd),-(v2.rev),-(v3.fwd));
# upper diagonal (last element is a garbage)
Au[[iw]]=c(0.,0.,0.,0.);spA[[iw]][0,0]=v2.fwd+v3.fwd;
spA[[iw]][1,0]=-(v3.fwd);
spA[[iw]][1,1]=v4.fwd+v2.rev;
spA[[iw]][2,1]=-(v2.rev);
spA[[iw]][2,2]=v2.fwd+v3.fwd;
spA[[iw]][3,2]=-(v3.fwd);
spA[[iw]][3,3]=v4.fwd+v2.rev;

# right hand side term b
b=c(v1.fwd*(x["A:2"]),0.,v1.fwd*(x["A:1"]),0.);

# solve the system A[[iw]]*x[<iw part>]=b[[iw]];
# x has to be global for all iw if we want to calculate b in simple way

iw=2;
if (length(Ac) < iw) {
   # initialiaze cumomer names
   cumos[[iw]]=c("B:3","C:3");
   ncumo[[iw]]=length(cumos);
   # init cumomer dependent vectors
   Al[[iw]]=Ac[[iw]]=Au[[iw]]=b[[iw]]=vector("numeric", ncumo[[iw]]);
   x=c(x,vector("numeric", ncumo[[iw]]);
   names(Al[[iw]])=names(Ac[[iw]])=names(Au[[iw]])=names(b[[iw]])=cumos[[iw]];
   names(x[(nx+1):(nx+ncumo[[iw]])]=cumos[[iw]];
   # ... and sparse part of the matrix
   spA[[iw]]=Matrix(0., ncumo[[iw]], ncumo[[iw]]);
   dimnames(spA[[iw]])=list(cumos[[iw]],cumos[[iw]]);
}
# central diagonal
Ac[[iw]]=c(v2.fwd+v3.fwd,v4.fwd+v2.rev);
# lower diagonal (first element is a garbage)
Al[[iw]]=c(-(v2.rev),-(v3.fwd));
# upper diagonal (last element is a garbage)
Au[[iw]]=c(-(v2.rev),-(v3.fwd));spA[[iw]][0,0]=v2.fwd+v3.fwd;
spA[[iw]][1,0]=-(v3.fwd);
spA[[iw]][0,1]=-(v2.rev);
spA[[iw]][1,1]=v4.fwd+v2.rev;

# right hand side term b
b=c(v1.fwd*(x["A:3"]),0.);

# solve the system A[[iw]]*x[<iw part>]=b[[iw]];
# x has to be global for all iw if we want to calculate b in simple way
